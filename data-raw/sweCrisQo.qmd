---
title: "Swecris/Case data assessment"
author:
  - name: Mohamad Bazzi
    orcid: 0000-0002-9495-0781
    email: bazzi@kth.se
    affiliations:
      - name: KTH Royal Institute of Technology 
        address: Osquars backe 31
        city: Stockholm
        postal-code: 114 28
highlight-style: pygments
format:
  html:
    toc: true
    toc-location: left
    code-fold: true
    html-math-method: katex
    embed-resources: true
  pdf:
    geometry: 
      - top=30mm
      - left=30mm
  docx: default
editor_options: 
  chunk_output_type: console
---

## Text blurb

Rationale --- To enhance existing information in CASE by supplementing missing or incomplete data.

```{r message=FALSE,warning=FALSE,results='hide',echo=TRUE}
R.packages <- c("devtools","bibliotools","dplyr","swecris","kthapi","grid",
                "gridExtra","stringdist","knitr","quarto","ggfittext","xml2",
                "ReDaMoR","gt","janitor","ggplot2","ggpubr","purrr","XML",
                "RecordLinkage","flextable","colorspace","fastLink","xlsx",
                "magrittr","kableExtra","VennDiagram","cld2","PGRdup",
                "fuzzyjoin","naniar","furrr","stringr","qpcR","dlookr",
                "cordis","openairegraph")

(lapply(R.packages, library, character.only = TRUE))
```

```{r}
source(file = "data-raw/customFunction.R")
```

## Data sources

Data download updated (2022-12-21)

```{r message=FALSE,echo=TRUE,results='hide'}
# All sweCris project, not limited to KTH associated.
swe.Total <- swecris_fundings()
# sweCris data (KTH only: 3068 observations as of 2022-12-21)
sw.Df <- swecris::swecris_kth
# CASE data (2514 observations)
ca.Df <- bibliotools::case()
# Adjust column names.
colnames(ca.Df)[16] <- "ProjectNumber"
colnames(ca.Df)[14] <- "PrimaryResearcher"
colnames(ca.Df)[6] <- "FundingOrganisation"
```

```{r echo=TRUE,out.width="50%",fig.cap="Figure 1. Data-driven flowchart (matching keys)."}
include_graphics("Figure-1.png")
```

## CASE data-quality

```{r echo=TRUE, fig.cap="Figure 2. Pareto chart for missing values (counts and proportions) in CASE."}
bazzi.na.Total(x = ca.Df, col = "black",typographic = T) + 
  theme(axis.text.x = element_text(size = 9,angle = 45),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

An initial evaluation of CASE indicates potential for improvement in overall data quality. Both adding and removing components are potential solutions.

### CASE data-quality by school

```{r out.width="100%", fig.cap="Figure 3. Pareto chart for missing values by school in CASE. Only variables with missing values are included."}
# School data-frame.
ca.school <- ca.Df
ca.school$school_short <- as.factor(ca.school$school_short)
# Split data-frame by factor.
school <- ca.school %>% 
  group_by(school_short)
# Droplevels, set names, and plot.
split.school <- group_split(school)
for(i in seq_along(split.school)) {
  split.school[[i]]$school_short <- droplevels(split.school[[i]]$school_short)
}
schoolName <- c("ABE","CBH","EECS","ITM","SCI")
ls.plot <- list()
for(i in seq_along(split.school)) {
  out <- split.school[[i]] %>% 
    bazzi.na.Partial(only_na = TRUE,col = "blue",typographic = T,
                   main = schoolName[i]) +
    theme(axis.text.x = element_text(size = 5),
          axis.text.y = element_text(size = 5),
          axis.title.x = element_text(size = 5),
          axis.title.y = element_text(size = 5),
          axis.title.y.right = element_text(size = NULL),
          plot.title = element_text(size=7),
          legend.title = element_text(size = 6),
          legend.text = element_text(size = 6),
          legend.key.size = unit(1,"mm"),
          legend.key.height= unit(1, 'mm'),
          legend.key.width= unit(1, 'mm'),
          plot.margin=unit(c(-0.5,1,1,1), "mm")) +
    coord_flip()
  ls.plot[[i]] <- out
}

do.call("grid.arrange", c(ls.plot, ncol=3))
```

On a school level, ABE has 17 fields with a missingness rate of more than 50%. CBH has 18 fields with a missingness of more than 50%. EECS and SCI schools both have 25 fields with missingness \> 50%. ITM has only 13 fields with missingness greater than 50%. In total, 28 fields were missing for NA.

## sweCris data-quality

```{r echo=TRUE, fig.cap="Figure 4. Pareto chart for missing values (counts and proportions) in sweCris."}
# Convert all Unknown to NA.
sw.Df[,] <- apply(sw.Df, 2, function(x) ifelse(x == "Unknown", NA, x))
# Plot.
bazzi.na.Total(x = sw.Df, col = "black",typographic = T) +
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

In the sweCris dataset, the column-wise completeness is generally satisfactory. The only notable exceptions are the abstract fields in both Swedish and English, which tend to have a high prevalence of missing data. Additionally, the project title in English is not consistently recorded with a high degree of accuracy.

------------------------------------------------------------------------

> ## 1A. Key: Project number

-   **Exact matches on ID**

The **Project number** variable in CASE correspond to the **Project ID** field in sweCris. However, to facilitate string intersection or matching, one is required to reformat the key in one of the datasets. A cursory view at the sweCris dataset reveal a predominantly consistent ID form/style. For that reason, I have chosen to use the sweCris ID format as a baseline for how to 'clean' CASE project numbers.

Exploratory data analysis reveal that the ID format in both datasets are organisation-specific (e.g. projects funded via the Swedish Energy Agency takes a unique form: see below). In the code that follows I have split the 'cleaning' procedure into first standardizing the Swedish Energy Agency funded project ID's (including the removal of empty values , non-numeric characters, and the addition of letters at the beginning and end of each ID), and then applying a similar set of operations to the remaining project data. More specifically, I created a new field corresponding to a 'clean ID' with only numeric characters and hyphen symbols retained. This was then filtered to keep elements with 10 characters only. The chosen value is not arbitrary, but is a reflection of the number of elements found in the majority-class of ID's in sweCris.

```{r warning=FALSE,message=FALSE,echo=TRUE,results='hide'}
# Subset CASE by Funding Organisation = Swedish Energy Agency.
sea.ca <- subset(ca.Df, FundingOrganisation == "Energimyndigheten")
# Remove NA and superfluous text.
sea.ca <- sea.ca[!is.na(sea.ca$ProjectNumber),]
sea.ca <- sea.ca[sea.ca$ProjectNumber %in% as.vector(na.omit(sea.ca$ProjectNumber[sapply(sea.ca$ProjectNumber, nchar) == 7])),]
# Add P to number strings.
sea.ca$ProjectNumber <- paste0("P", gsub("","",sea.ca$ProjectNumber))
# Add organisation name to string.
sea.ca$ProjectNumber <- paste(sea.ca$ProjectNumber,"_Energi")
sea.ca$ProjectNumber <- gsub("\\s","", sea.ca$ProjectNumber)
# Repeat: Keep numbers only.
ca.Df["clean.IDA"] <- gsub("[^0-9.-]","",ca.Df$ProjectNumber)
# Keep 10 character elements only.
ca.Df.sub <- ca.Df[ca.Df$clean.IDA %in% as.vector(na.omit(ca.Df$clean.IDA[sapply(ca.Df$clean.IDA, nchar) == 10])),] # 278 observations.
ca.Df.sub$clean.IDA <- gsub("^-","",ca.Df.sub$clean.IDA)
# Remove empty funding organisation.
ca.Df.sub$FundingOrganisation[ca.Df.sub$FundingOrganisation == "Not Applicable N/A"]  <- ""
# Standardize against sweCris names.
ca.Df.sub$FundingOrganisation <- recode(ca.Df.sub$FundingOrganisation,
                                         Energimyndigheten = "Energi",
                                         VINNOVA = "Vinnova",
                                         VetenskapsrÃ¥det = "VR")
# Combine
ca.Df.sub["clean.IDA"] <- paste(ca.Df.sub$clean.IDA,ca.Df.sub$FundingOrganisation, sep = "_")
ca.Df.sub["clean.IDA"] <- gsub("^-","",ca.Df.sub$clean.IDA)
# Combine dataframes.
cleanID.CASE <- dplyr::bind_rows(sea.ca,ca.Df.sub) # 348 observations.
cleanID.CASE[1:78,"clean.IDA"] <- cleanID.CASE[1:78,"ProjectNumber"]
# Remove missing organisations.
cleanID.CASE <- cleanID.CASE[!cleanID.CASE$FundingOrganisation == "",] # 352 observations.
```

```{r echo=TRUE,results='hide'}
# How many in 00000-0_ZZ shape in sweCris? They are all Energy funded 
as.vector(na.omit(str_extract(sw.Df$ProjectId, "(\\d+)-(\\d{1})_[:alpha:]+"))) %>%
  length() # 369 (11.76%)
# How many in 0000-00000_ZZ format?
as.vector(na.omit(str_extract(sw.Df$ProjectId, "(\\d+)-(\\d{5})_[:alpha:]+"))) %>%
  length() # 2611 (85%). In total with the aforementioned = 96.76%
```

### Duplicates in CASE

In total, there are 25 instances of duplicate project titles within the CASE database. At the specific level of research projects, there are 11 duplicate titles present. These duplicate projects can be identified by their distinct project IDs and varying statuses, such as application, ongoing, or rejected.

```{r fig.cap="Figure 5. Inspection of duplicate project titles in a case."}
# Title duplicates in title name.
# ca.Df[duplicated(ca.Df["Name"], fromLast = T), ]
# Title duplicates in title names for research projects.
res_proj <- ca.Df[ca.Df$type == "Research project", ]
# na.omit(res_proj$Name[duplicated(res_proj$Name)]) %>% length
# Examine the projects with n > 1.
res_proj_dup <- 
  ca.Df[ca.Df$Name %in% (res_proj$Name[duplicated(res_proj$Name)])[-c(1:2)],] %>%
  filter(type != "Research Infrastructure")
# Plot results.
res_proj_dup %>%
  ggplot(mapping = aes(x = `Project ID`, fill = Status)) +
  geom_bar() + facet_wrap(.~Name+FundingOrganisation, scales = "free")
```

### Pattern expressions (Project Number)

At the character level there are 37 levels. Each level (e.g., "10" may include several ID formats).

```{r fig.cap="Figure 6. Regeular expression. Using character count as a representation of the frequency of Project Numbers in CASE"}
# How many different patterns are available in the Project Number field?
ids <- na.omit(ca.Df$ProjectNumber)
# Data frame.
ids.nchar <- data.frame(ids = ids,
                        char.num = nchar(ids),
                        name = ca.Df[ca.Df$ProjectNumber %in% ids,]$Name)

# At the character level there are 37 levels.
# Each level (e.g., "10" may include several ID formats)
ids_expression <- ids.nchar %>% 
  dplyr::group_by(char.num) %>% count(sort = T) %>% print(n = 37)

# Extract the values for a specific char.num
values_for_char_num <- ids.nchar %>% 
  filter(char.num == 10) %>% 
  pull(ids)

attributes(values_for_char_num)$na.action <- NULL
# Plot.
ids_expression %>%
  ggplot(mapping = aes(x = as.factor(char.num),y = n)) +
  geom_col() + theme(aspect.ratio = 1/2)
```

```{r}
# How many true duplicated are there?
true_dup <- ids.nchar %>%
  dplyr::select(-starts_with("name")) %>%
  add_count(ids) %>%
  filter(n > 1) %>%
  distinct()

true_dup_df <- ca.Df[ca.Df$ProjectNumber %in% true_dup$ids,] %>% 
  filter(type == "Research project")

true_dup_df[true_dup_df$ProjectNumber]

ca.Df$ProjectNumber
# Are these the same projects or are they completely different?
ids.nchar %>%
  group_by(ids) %>%
  filter(n()>1) %>%
  ungroup() %>% arrange(desc(ids))
```

```{r echo=TRUE, results='hide',message=FALSE}
# Table 1.
Tab.1 <- ca.Df %>%
  group_by(FundingOrganisation) %>%
  count(sort = F)
# Table 2.
Tab.2 <- sw.Df %>%
  group_by(FundingOrganisationNameSv) %>%
  count(sort = F)
# Table 3 (Hypothetical matches)
Fund.Org <- c("VR","VINNOVA","Formas","Energimyndigheten",
              "Rymdstyrelsen","Forte","Riksbankens Jubileumsfond")

Tab.3 <- cbind(Tab.2,Tab.1[Tab.1$FundingOrganisation %in% Fund.Org, ])

Tab.3[,3:4] <- Tab.3[c(2,3,4,5,1,7,6),3:4]

colnames(Tab.3)[1] <- "sweCris"
colnames(Tab.3)[2] <- "Sample"
colnames(Tab.3)[3] <- "CASE"
colnames(Tab.3)[4] <- "Sample"
# 720 Projects.
sum(Tab.1[Tab.1$FundingOrganisation %in% Fund.Org, ]$n)
```

```{r echo=TRUE}
knitr::kable(x = Tab.3,
caption = "Table 1. Agencies involved in project funding in CASE. The funding organization is unknown for 566 CASE projects. SweCris has seven funding agencies and CASE has 29. The hypothetical project match is 720. The question that follows is how many projects can we match using available identifiers?",format="markdown")
```

------------------------------------------------------------------------

**Remarks including recommendations**

1.  The project number field in CASE would benefit from a re-structuring and consistent ID formatting across projects. This would make database comparisons much easier. Equally, the high frequency of NA's (n=1503) in the Project Number column, along with at least 8 true duplicates and one triplet constitutes an additional data-quality issue in CASE. These duplicated IDs do not correspond to duplicated project names. This means that a few projects in CASE have similar IDs. Finally, of the 2514 project listed in the CASE dataframe only 1011 have assigned "Project Numbers" the rest are Na's.

2.  Furthermore, project ID's associated with the **Swedish Energy Agency** often lack the initial **P** letter. Additionally, many projects lack an ID in entirety, some have more than one ID along with text, and others are made up by text only. This makes this field very unstructured.

3.  Other data-set pathologies in CASE include high proportion of missingness and projects with similar project titles (i.e. duplicates).

4.  **ID cleaning was done using a three-step process:**

-   Removal of all non-numeric characters.
-   Retaining all 9 digits + hyphen elements (this is the conventional label shape in sweCris: also see note above).
-   Add funding organisation to CASE ID.

```{r echo=TRUE,results='hide'}
sweCris.format <- data.frame(Format = c("P00000-0_ZZ","0000-00000_ZZ",
                                        "000/00_ZZ","00/00_ZZ"),
                             Percentage = c("11.76","85.0","1.43","1.88"),
                             N = c(369,2680,45,59),
                             Remarks = c("Swedish Energy Agency affiliated",
                                         "VR, Vinnova, & Formas",
                                         "SNSB affiliated","SNSB affiliated"))
```

```{r echo=TRUE}
knitr::kable(x = sweCris.format,
             caption = "Table 2. There are at least eight different ID styles/formats in sweCris. Together, 0000-00000_ZZ and P00000-0_ZZ make up 96.76% of all ID patterns in sweCris.") %>% 
  kable_styling() %>%
  kableExtra::add_footnote(label = "Not all are shown")
```

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# Subset CASE data (both NA's and duplicates in Project Number are removed)
cleanID.CASE <- cleanID.CASE %>%
  filter(!duplicated(clean.IDA)) %>%
  filter(!duplicated(Name)) # 350 projects.

# Confirm. Looks fine.
which(duplicated(x = cleanID.CASE$Name) == T)
which(duplicated(x = cleanID.CASE$clean.IDA) == T)
# How many ID's match?
# 123 projects match. This approach might be to stringent. Attempt fuzzy or other methods of matching.
generics::intersect(cleanID.CASE$clean.IDA,sw.Df$ProjectId) %>% length()

# Initial match. This will add information to those project that match between the datasets. Adds 27-1 more variables. Check their level of completeness.
Match.1 <- cleanID.CASE %>% 
  left_join(sw.Df, by = c("clean.IDA" = "ProjectId"))

# Parse out the projects that matched: this is equivalent to an inner join.
MissCheck.1 <- Match.1[Match.1$clean.IDA %in% generics::intersect(cleanID.CASE$clean.IDA,sw.Df$ProjectId), ]

MissCheck.1 <- MissCheck.1 %>% 
  mutate(across(c("ProjectTitleSv","ProjectTitleEn",
                  "ProjectAbstractSv","ProjectAbstractEn"), na_if, "Unknown"))

# Projects assoicated with 4 funding organizations were retrived.
# This leaves out projects funded by Forte, Riksbankens Jubileumsfond, and Rymdstyrelsen.      
MissCheck.1 %>%
  group_by(FundingOrganisation) %>%
  summarise(n = n()) %>%
  arrange(-n)

# Degree of missingness?
sapply(MissCheck.1[,1:40], function(x) sum(is.na(x)))
sapply(MissCheck.1[,41:66], function(x) sum(is.na(x)))
```

### Data quality after matching

```{r echo=TRUE,fig.cap="Figure 5. Pareto chart for missing values (counts and proportions) in the reduced CASE dataset (i.e. the remaining projects that satisfies the matching criterion using ID)."}
bazzi.na.Total(x = MissCheck.1, col = "black",typographic = T) + 
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

**Results (1/3)**

1.  The number of project matches depend on how ID standardization is done.
2.  Using the two predominant ID styles in sweCris (see above) as a reference, yields 123 distinct project matches.
3.  Generally, most CASE ID's are inconsistently written, which makes it very difficult to merge against sweCris.
4.  The issue is further exacerbated by variable ID formats in sweCris. But is generally better than CASE.
5.  Of the **350 CASE projects** with a clean ID, only [**35% (N=123)**]{.underline} could be matched against the sweCris dataset.
6.  Viewed altogether, only **4.89%** of unique CASE projects (N=2512) could be detected in sweCris using project ID as an identifier.
7.  Matching against all sweCris projects (i.e. swe.Total) returned **269** matches.
8.  Overall, despite the low number of project matches, the added information retrieved via sweCris is rather complete (column-wise). This is unsurprising as the data quality in sweCris tends to be better.

------------------------------------------------------------------------

```{r warning=FALSE,message=FALSE,echo=TRUE,fig.show='hide'}
# Venn diagram showing project overlap based on project ID's.
mP1 <- draw.pairwise.venn(area1= 3068,area2 = 992,
                          cross.area = 123,
                          category = c("sweCris projects with an ID",
                                       "CASE projects with an ID"),
                          fill = c("grey80","#7b0323"),
                          scaled = T,cex = 1,
                          rotation.degree = 45)
```

```{r echo=TRUE,fig.cap="Figure 6. Venn diagram showing project overlap based on project ID's. Area 1 (Grey) = the total number of unqiue project ID's in sweCris. Area 2 (Red) = the total number of unique project number is CASE with a similar ID format."}
ggarrange(mP1) + theme(aspect.ratio = 1)
```

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# Match against all sweCris projects.
allSweCris <- generics::intersect(cleanID.CASE$clean.IDA,swe.Total$projectId) # 269 matches.
allSweDf <- swe.Total[swe.Total$projectId %in% (allSweCris),]
allSweDf <- allSweDf %>% filter(!duplicated(projectId))
# Which are the coordinating organisations?
allSweDf %>% group_by(coordinatingOrganisationNameEn) %>% count(sort = T)
allSweDf %>% group_by(fundingOrganisationNameSv) %>% count(sort = T)
# Compare with CASE.
cleanID.CASE %>% group_by(Role) %>% count(sort = T)
```

> ## 1B. Key: Project number
>
> **In-exact matches on ID**

```{r warning=FALSE, message=FALSE, echo=TRUE}
# Fuzzy matching.
Fuzz.ID <- cleanID.CASE %>%
  stringdist_inner_join(x = sw.Df,by = c(ProjectId = "clean.IDA")) %>%
  filter(!duplicated(clean.IDA)) %>%
  filter(!duplicated(Name))

Fuzz.ID["lev"] <- lev <- levenshteinSim(Fuzz.ID$clean.IDA,Fuzz.ID$ProjectId)
Fuzz.ID["jaro"] <- jaro <- jarowinkler(Fuzz.ID$clean.IDA,Fuzz.ID$ProjectId)
```

**Evaluating fuzzy matching**

```{r echo=TRUE}
knitr::kable(slice_head(Fuzz.ID[,c("clean.IDA","ProjectId","lev","jaro")],n = 10),
  caption = "Table 3. Fuzzy matching. Lev = levenshtein distance (%), jaro = jaro-winkler distance.",
  digits = 2) %>%
  kable_styling()
```

**Miss-classification rate**

```{r echo=TRUE}
paste(round(100-(which(Fuzz.ID$lev == 1.0000000) %>% 
                   length()/(length(Fuzz.ID$lev)))*100,2),"%")
```

------------------------------------------------------------------------

> ## 2. Key: Project Title.

The main problem with matching against **Project Title** is that CASE does not provide the information in a consistent format/language.

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# How many NA project titles are there in sweCris?
sum(is.na(sw.Df$ProjectTitleSv)) # 77.
sum(is.na(sw.Df$ProjectTitleEn)) # 420.
# How many NA project titles are there in CASE?
sum(is.na(ca.Df$Name)) # 3
```

```{r warning=FALSE, message=FALSE, echo=TRUE,results='hide'}
# Add
ca.Df["language"] <- NA
# Language identifier
system.time(
  for(i in 1:length(ca.Df$Name)) {
  ca.Df$language[[i]] <- tolower(cld2::detect_language(text = ca.Df$Name[[i]],
                                                       plain_text = T,
                                                       lang_code = F))
}
)

# Correct
ca.Df$language[ca.Df$language == "norwegian"] <- "swedish"
# Summary.
ca.Df %>%
  group_by(ca.Df$language) %>%
  count(sort = T) %>%
  print(n=45)

# Unknowns, are a mix of Swedish & English titles.
ca.Df$language[is.na(ca.Df$language)] <- "Unknown"
# Other languages?
ca.Df %>% group_by(Name,language) %>%
  dplyr::select(Name,language) %>%
  filter(language == "welsh" | language == "uzbek" | 
         language == "turkish" | language == "portuguese" |
         language == "nyanja" | language == "kurdish" |
         language == "indonesian" | language == "hungarian" |
         language == "galician" | language == "croatian" |
         language == "catalan" | language == "albanian" |
         language == "afrikaans" | language == "spanish" |
         language == "kinyarwanda" | language == "ganda" |
         language == "estonian" | language == "basque" |
         language == "german") %>% 
  print(n = 27)
```

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# Subset based on intersection.
# Remove extra spaces and use case-folding to improve intersection.
merge.titles <- c(generics::intersect(x = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT")),
                                      y = gsub("\\s+"," ",iconv(tolower(na.omit(sw.Df$ProjectTitleSv)),to = "ASCII//TRANSLIT"))),
                  generics::intersect(x = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT")),
                                      y = gsub("\\s+"," ",iconv(tolower(na.omit(sw.Df$ProjectTitleEn)),to = "ASCII//TRANSLIT"))))
# Any duplicates? Yes.
duplicated(merge.titles)
# Remove.
merge.titles <- unique(merge.titles) # 136. Although not that good, this is still better than project ID.
# Subset
sub.ca.Df.2 <- ca.Df
sub.ca.Df.2$Name <- gsub("\\s+"," ",iconv(tolower(ca.Df$Name),
                                          to = "ASCII//TRANSLIT"))

sub.ca.Df.2 <- sub.ca.Df.2[sub.ca.Df.2$Name %in% merge.titles, ]
sub.ca.Df.2$Name[duplicated(sub.ca.Df.2$Name)]

# Clean
sub.ca.Df.2 <-
  sub.ca.Df.2 %>%
  group_by(Name) %>%
  filter(!duplicated(Name))

# sweCris modification to enable inner-join.
modify.sw.Df <- sw.Df
modify.sw.Df$ProjectTitleSv <- gsub("\\s+"," ",
                                    iconv(tolower(sw.Df$ProjectTitleSv),
                                          to = "ASCII//TRANSLIT"))
modify.sw.Df$ProjectTitleEn <- gsub("\\s+"," ",
                                    iconv(tolower(sw.Df$ProjectTitleEn),
                                          to = "ASCII//TRANSLIT"))

# Merge in a two step fashion.
parseSwe <- ca.Df %>%
  filter(!is.na(Name)) %>%
  mutate(Name = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),
                                      to = "ASCII//TRANSLIT"))) %>%
  group_by(Name) %>% 
  filter(!duplicated(Name)) %>% 
  inner_join(modify.sw.Df, by = c("Name" = "ProjectTitleSv"))
  # distinct(Name)

parseEng <- ca.Df %>%
  filter(!is.na(Name)) %>%
  mutate(Name = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),
                                      to = "ASCII//TRANSLIT"))) %>%
  group_by(Name) %>% 
  filter(!duplicated(Name)) %>% 
  inner_join(modify.sw.Df, by = c("Name" = "ProjectTitleEn"))
  # distinct(Name)

# Match by project title enrichment.
Match.2 <- rbind(parseSwe,parseEng)
Match.2 <- Match.2 %>% filter(!duplicated(Name))
```

```{r}
# Create one title field in sweCris.
sw.Df <- sw.Df %>% mutate(Unified.Title = 
                            ifelse(is.na(ProjectTitleEn),
                                   ProjectTitleSv,ProjectTitleEn))
```

**Results (2/3)**

1.  136 matches based on Project Title. This is on par with the number of matches captured using Project ID.
2.  **Data-quality issues:** Three NA's in the Name/Title field in Case. At least 4 project titles have triplet occurrences, and 16 titles occur twice (i.e. duplicates) in Case.
3.  **Data-quality issues:** In sweCris there are 78 project titles that are pure duplicates, 5 triplets, and four quadruplets.

```{r echo=TRUE, fig.show='hide'}
## Venn diagram showing projects overlap based on project title.
mP2 <- draw.pairwise.venn(area1= 2968,area2 = 2486,
                          cross.area = 136,
                          category   = c("SweCris-titled projects",
                                         "CASE-titled projects"),
                          fill = c("grey80","darkcyan"),
                          scaled = T,cex = 1,
                          rotation.degree = 45)
```

```{r echo=TRUE,fig.cap="Figure 7. Venn diagram showing project overlap based on project title. Area 1 (Grey) = represent unique project titles in sweCris. Area 2 (Red) = represent unique project names (i.e. title) in CASE."}
ggarrange(mP2) + theme(aspect.ratio = 1)
```

------------------------------------------------------------------------

**Combined results**

```{r fig.cap="Figure 8. Comparison of results",fig.align='center'}
ggarrange(mP1,mP2) + theme(aspect.ratio = 1/2)
```

**Does ID vs Title identifiers return the same matching projects?**

No. Only, 74 projects are the same. In other words, the project match depend to some extent on the identifier being used. Jointly, however, ID and Project Title yield **188 project matches** against sweCris.

```{r echo=TRUE,results='hide'}
generics::intersect(gsub("\\s+"," ",
                         iconv(tolower(na.omit(MissCheck.1$Name)),
                               to = "ASCII//TRANSLIT")),Match.2$Name)

generics::setdiff(gsub("\\s+"," ",
                       iconv(tolower(na.omit(MissCheck.1$Name)),
                             to = "ASCII//TRANSLIT")),Match.2$Name)
# Combine.
Total.M1 <- merge(MissCheck.1,Match.2,all = T)
Total.M1$Name <- iconv(tolower(Total.M1$Name),to = "ASCII//TRANSLIT")
# Subset.
Total.M1 <- Total.M1 %>%
  filter(!duplicated(Name))
```

**Fuzzy-matching based on title sound**

**Gestalt pattern matching**

This adds an additional 11 projects using soundex method followed by jarowinkler computation of similarity.

```{r eval=FALSE, echo=TRUE,results='hide'}
fuzzy_Title_SX <- ca.Df %>%
  fuzzyjoin::stringdist_inner_join(sw.Df, by=c(Name="Unified.Title"),
                       method="soundex", max_dist = 0) %>%
  filter(!duplicated(ProjectId)) %>%
  filter(!duplicated(Name))

fuzzy_Title_SX["JW"] <- lev <- jarowinkler(fuzzy_Title_SX$Name,
                                           fuzzy_Title_SX$Unified.Title)
# Check again
EXA <- fuzzy_Title_SX %>% 
  filter(JW >= .85) %>%
  mutate(ProjectTitleEn = gsub("\\s+"," ",iconv(tolower(EXA$ProjectTitleEn),
                                                to = "ASCII//TRANSLIT")))
# How many extra? 11 projects.
rM <- generics::intersect(Match.2$ProjectTitleEn,
                          gsub("\\s+"," ",iconv(tolower(EXA$ProjectTitleEn),
                                                to = "ASCII//TRANSLIT")))

EXB <- EXA[!(EXA$ProjectTitleEn %in% c(rM)), ]
# Combine extras with exact title matches.
Match.2B <- rbind(Match.2,EXB)
Match.2B <- Match.2B %>% filter(!duplicated(Name))
```

------------------------------------------------------------------------

> ## 3. Key: Primary Researcher

1.  The **InvolvedPeople** column have a complex string structure with relevant information that ought to be parsed out to facilitate maximum matching with the CASE database. The main problem here is that the name of the project leaders, including participating researchers are bind into poorly structured text strings. To circumvent, I have attempted to parse out **name** and **role** based on their general position in each string.

2.  The **primary researcher** information is missing from 103 projects in SweCris. Six of these do however include partial information, but not the name of the PI.

3.  The name of 2965 Principal Investigators (96.64%) could successfully be collected via sweCris.

4.  **419 exact name matches between CASE and sweCRIS.**

```{r echo=TRUE}
sw.Df["PrimaryResearcher"] <- ""
sw.Df["Leading.Role"] <- ""

# Generalize.
for(i in 1:length(sw.Df$InvolvedPeople)) {
  # Index.
  iX <- strsplit(sw.Df$InvolvedPeople[[i]],"Â¤")[[1]][-c(1:3)]
  # Attain name via PI position
  sw.Df$PrimaryResearcher[[i]] <- iX[grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[i]],"Â¤")[[1]][-c(1:3)])[1]-2]
  # Clean names, with no extra spaces.
  sw.Df$PrimaryResearcher[[i]] <- gsub("\\s+"," ",sw.Df$PrimaryResearcher[[i]])
  # Remove accents.
  # sw.Df$PrimaryResearcher[[i]] <- iconv(sw.Df$PrimaryResearcher[[i]],to = "ASCII//TRANSLIT")
  # Role.
  sw.Df$Leading.Role[[i]] <- iX[grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[i]],"Â¤")[[1]][-c(1:3)])[1]]
}
```

```{r echo=TRUE,results='hide'}
# Summarize.
sw.Df %>% group_by(Leading.Role) %>% count(sort = T)
sw.Df %>% group_by(PrimaryResearcher) %>%
  filter(PrimaryResearcher != "Unknown") %>%
  count(sort = T) %>%
  filter(n > 1) %>%
  ggplot(aes(x = as.factor(PrimaryResearcher), y = n)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  labs(x = "Primary Researcher")
# Summarize.
ca.Df %>%
  group_by(PrimaryResearcher) %>%
  count(sort = T)

colnames(sw.Df)
```

```{r}
swecris_project_people(project_id = "2021-00527_Formas")

names(sw.Df)
sw.Df %>% dplyr::group_by()
```

```{r echo=TRUE,results='hide'}
# Re-code.
sw.Df[is.na(sw.Df)] <- "Unknown"
sw.Df.Unknown <- subset(sw.Df,(Leading.Role %in% "Unknown"))
# Rows (n=6) were Involved People have limited information, but not Principal Investigator.
string.InNA <- c(7,15,40,54,66,80)
# Subset to retain all NA.
sw.df.Partial <- sw.Df.Unknown[string.InNA, ]

sw.Df %>% names
```

```{r echo=TRUE,results='hide'}
# Remove accent from names in CASE:
# ca.Df$PrimaryResearcher <- iconv(ca.Df$PrimaryResearcher,to = "ASCII//TRANSLIT")

# How many name matches?
generics::intersect(na.omit(ca.Df$PrimaryResearcher),
                    na.omit(sw.Df$PrimaryResearcher)) %>% unique()
generics::intersect(na.omit(ca.Df$PrimaryResearcher),
                    na.omit(sw.Df$PrimaryResearcher)) %>% unique() %>% length()
generics::intersect(na.omit(ca.Df$PrimaryResearcher),
                    na.omit(sw.Df$PrimaryResearcher)) %>% length()
```

```{r echo=TRUE}
# Project Match.
Match.3 <- ca.Df %>% 
  left_join(sw.Df, by = "PrimaryResearcher",na_matches = "never") %>%
  filter(!is.na(PrimaryResearcher)) %>%
  filter(!is.na(Leading.Role)) %>%
  filter(!duplicated(Name)) %>%
  filter(!duplicated(Unified.Title))
```

```{r echo=TRUE,fig.cap="Figure 12. Pareto chart for missing values (counts and proportions) in the reduced CASE dataset."}
bazzi.na.Total(x = Match.3, col = "black",typographic = T) + 
  theme(axis.text.x = element_text(size = 9,angle = 45),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

**Results (3/3)**

1.  419 exact name matches. Better than ID and Project title combined. But this is probably an underestimation anyway. The complete name may not include 'middle names' in CASE.

```{r echo=TRUE,fig.show='hide'}
## Venn diagram showing projects overlap based on project title.
mP3 <- draw.pairwise.venn(area1= 3068,area2 = 2514,
                          cross.area = 419,
                          category = c("SweCris: Primary Researcher",
                                       "CASE: PrimaryResearcher"),
                          fill = c("grey80","blue"),
                          cat.col = "black",cat.cex = 1,
                          scaled = T,cex = 1,
                          rotation.degree = 45)
```

```{r echo=TRUE,fig.cap="Figure 13. Venn diagram showing project overlap based on Primary Researcher Area 1 (Grey) =  Area 2 (Red) = "}
ggarrange(mP3) + theme(aspect.ratio = 1)
```

```{r echo=TRUE}
# Combine ID, Title, and Primary Research
Total.M2 <- merge(Total.M1,Match.3,all = T)
Total.M2$Name <- tolower(iconv(Total.M2$Name,to = "ASCII//TRANSLIT"))
Total.M2 <- Total.M2 %>% filter(!duplicated(Name)) # 552 unique projects in total.

# How many are VR?
Total.M2 %>% group_by(FundingOrganisation) %>% count(sort = T)
```

```{r echo=TRUE,fig.cap="Figure 14. Venn diagram showing project overlap based on Id, Title, and Primary Researcher."}
ggarrange(mP1,mP2,mP3,nrow = 1,heights = c(2,2),widths = c(4,4)) + 
  theme(aspect.ratio = 1/2)
```

## Section summary --- Case vs sweCris

The main results revealed several issues with the data quality in the CASE dataset, particularly in the Project Number field which would benefit from a re-structuring and consistent ID formatting across projects to make database comparisons more efficient.

The results of the study found that the number of project matches depends on how ID standardization is done. Using the two predominant ID styles in sweCris as a reference, 123 distinct project matches were obtained. However, generally, most CASE IDs are written inconsistently, making it difficult to merge with sweCris. The issue is further compounded by variable ID formats in sweCris, although it is generally better than CASE. Out of 350 CASE projects with a clean ID, only 35% (N=123) could be matched against the sweCris dataset. In total, only 4.89% of unique CASE projects (N=2512) could be detected in sweCris using the project ID as an identifier. Despite the low number of project matches, the added information retrieved from sweCris is generally complete (column-wise) as the data quality in sweCris tends to be better.

Results based on the project title found 136 matches, which is on par with the number of matches captured using the project ID. However, there are data-quality issues in both datasets, with three missing values in the Name/Title field in CASE and 78 project titles that are pure duplicates, 5 triplets, and four quadruplets in sweCris. Using ID vs Title identifiers returned different matching projects, with only 74 projects being the same. Jointly, however, ID and Project Title yield 188 project matches against sweCris.

The results based on the primary researcher found that the InvolvedPeople column has a complex string structure with relevant information that ought to be parsed out to facilitate maximum matching with the CASE database. The name of 2965 Principal Investigators (96.64%) could be successfully collected via sweCris and 419 exact project matches between CASE and sweCRIS were found. This was better than ID and Project title combined. However, it is probably an underestimation as the complete name may not include 'middle names' in CASE.

In total, 552 unique projects can be matched based on ID, Title, and Primary Researcher. This means that of the 720 potential project fits, 76% were captured, with 24% missing.

**Ancillary remarks**. Obviously, a primary risk is the difficulty in integrating with other systems. (e.g. sweCris). Data quality is also a concern as Case have different levels of data quality. Additionally, if the databases are not representative of the population (e.g. ITM) being studied, it can lead to biased conclusions from the analysis. Lastly, if the databases contain duplicates, it can lead to confusion and inaccuracies in the analysis.

------------------------------------------------------------------------

> ## 4. External Key: ORCID ID

```{r echo=TRUE,results='hide',message=FALSE,warning=FALSE}
# ugkthId & Orcid.
ug <- readr::read_csv(rawToChar(kthcorpus::minio_get("ug_kthid_orcid.csv",
                                                     bucket = "kthcorpus")))
# unique ugkthId.
lookup <- readr::read_csv(rawToChar(kthcorpus::minio_get("ug_kthid_unit.csv",
                                                         bucket = "kthcorpus")))

names(ca.Df)
ca.Df %>% View()
```

```{r}
# How many Primary Researchers in CASE dont have an CORCID ID?
# N = 127.
ca.Df %>%
  filter(type == "Research project") %>%
  group_by(username) %>% count() %>% arrange(desc(n))%>%
  left_join(lookup, by = c("username" = "ugUsername")) %>%
  dplyr::select(username, ugOrcid, ugKthid, n) %>%
  filter(is.na(ugOrcid))

ca.Df %>%
  filter(type == "Research project") %>%
  group_by(username,PrimaryResearcher) %>% count() %>% arrange(desc(n))%>%
  left_join(lookup, by = c("username" = "ugUsername")) %>%
  dplyr::select(username, ugOrcid, ugKthid, n) %>%
  filter(is.na(ugOrcid))
```

```{r echo=TRUE, results='hide'}
# Merge by username and remove incomplete cases (subset by ugOrcid)
# N = 1332 research projects.
exDf.ca <- ca.Df %>%
  filter(type == "Research project") %>%
  left_join(lookup, by = c("username" = "ugUsername")) %>%
  filter(!is.na(ugOrcid)) %>%
  filter(!duplicated(Name))

sapply(exDf.ca[c("ProjectNumber","Name")],function(x) duplicated(x))

# Unique ORCID IDs (N = 458)
distinct.orcidID <- unique(exDf.ca$ugOrcid)
```

**Call sweCris api to get project results**

```{r cache=TRUE,results='hide'}
# Initialize empty list to store the results
res <- list()
# Iterate over each ORCID ID
for (i in 1:458){
    orcid <- distinct.orcidID[i]
    res[[i]] <- tryCatch(swecris::swecris_projects_from_orcid(orcid),
                         error=function(e) e)
}

# Flatten.
op <- unlist(res,recursive = FALSE)
# Projects
op_projects <- op[sapply(op, function(x) any(grepl("project", names(x))))]
projects <- do.call(rbind, op_projects)
projects <- projects %>% distinct() # 
# People Lsit
op_peopleList <- op[sapply(op, function(x) any(grepl("fullName", names(x))))]
peopleList  <- do.call(rbind,op_peopleList)
peopleList %>% group_by(fullName,roleEn) %>% count()
# Scbs
op_scbs <- op[sapply(op, function(x) any(grepl("scb1NameEn", names(x))))]
scbs <- do.call(rbind, op_scbs)
```

A total of 854 projects were retrieved by using orchid-ID's associated with primary researchers at KTH. The question that arises is to what extent these projects align with those in CASE.

```{r}
# Project title.
Match.5A <- inner_join(ca.Df, projects, by = c("Name" = "projectTitleEn"))
Match.5B <- inner_join(ca.Df, projects, by = c("Name" = "projectTitleSv"))
Match.5C <- dplyr::bind_rows(Match.5A,Match.5B) # 56 project matches.
```

The number of project matches based on title and ID are the same (N = 56 each)

```{r}
# Match clean CASE data versus Orcid based on Project ID.
# This is futile, only 44 matches.
Match.4 <- cleanID.CASE %>%
  dplyr::inner_join(projects,by = c(clean.IDA = "projectId"),keep = TRUE)

# Match.4[,c("projectId","clean.IDA")] %>% dplyr::slice_head(n = 10)

# CASE copy
case.orcid <- ca.Df
# Project title (number of project matches based on title, N = 56)
Match.5A <- inner_join(case.orcid, projects, by = c("Name" = "projectTitleEn"))
Match.5B <- inner_join(case.orcid, projects, by = c("Name" = "projectTitleSv"))
Match.5C <- dplyr::bind_rows(Match.5A,Match.5B)

# Fussy attempt on title.
Match.5D <- stringdist_inner_join(x = case.orcid[!is.na(case.orcid$Name),],
                                  y = projects, by = c("Name" = "projectTitleEn"))
Match.5E <- stringdist_inner_join(x = case.orcid[!is.na(case.orcid$Name),],
                                  y = projects, by = c("Name" = "projectTitleSv"))
# Plot matching results.
Orcid.Match.Res <- data.frame(ID = c("43","58"),
                              class = c("CASE vs Orcid ID",
                                        "CASE vs Orcid Title"))
Orcid.Match.Res %>% 
  ggplot(aes(x = class, y = ID)) +
  geom_bar(stat = "identity") + 
  labs(title = "Matches by identifier: Primary research ORCID ID") +
  theme_minimal()
```

## Section summary --- Case vs Orcid

Out of the primary researchers in CASE, 127 do not have an ORCID ID. In total, there are 458 distinct ORCID ID's associated with research projects in CASE. By using these ORCID ID's to retrieve data through sweCris, 854 projects were obtained. To determine if there is overlap between these projects and those in CASE, I compared the exact ID's and project titles. The results indicate that there is very little overlap between the projects in CASE and those found in the sweCris database. It's unclear why these data source are so seemingly difficult to compare.

------------------------------------------------------------------------

## CORDIS vs CASE

CORDIS is the primary source of results from EU-funded projects.

Search term --- **KUNGLIGA TEKNISKA HOEGSKOLAN (org.Id = 999990946).** 760 results for ''999990946'' KTH projects in Cordis. [Cordis -- EU:s forskningsprojekt inom Horisont 2020 (2014--2020) - Data Europa EU](https://data.europa.eu/data/datasets/cordish2020projects?locale=sv)

```{r echo=TRUE, results='hide'}
# Import xml files.
data_list <- list()
path <- "C:/Repos/swecris/cordis xml/"
# XML files in the directory
for(i in list.files(path = path, pattern = ".xml")) {
  # Create the full file path
  file_path <- paste0(path, i)
  # Read in the XML file
  xml_data <- read_xml(file_path)
  # Append the xml data to the data_list
  data_list[[i]] <- xml_data
}

# Connection.
con <- cordis_con()
# PI data
PI.Df <- con %>% tbl("pi") %>% as.data.frame()
  # Project ID, First and Last Name.
PI.Df %>%
  dplyr::select(projectId,firstName,lastName,organisationId) %>%
  filter(organisationId == "999990946")# KTH org.

# Project data.
cordis.projects <- con %>% tbl("projects") %>%
  as.data.frame() # %>%
  # View() # id, topics, title, start & end date.

# How many porjects are KTH?
cordis.projects %>%
  filter(coordinator == "KUNGLIGA TEKNISKA HOEGSKOLAN" |
         participants == "KUNGLIGA TEKNISKA HOEGSKOLAN") %>% nrow() # 67

# Organizations.
cordis.org <- con %>% tbl("organizations") %>%
  as.data.frame()

# Publications data
cordis.pbd <- con %>% tbl("projectpublications") %>%
  dplyr::select(-starts_with(match = "X")) %>%
  filter(!is.na(title)) %>%
  as.data.frame()
  # title, projectID

cordis_disconnect(con)
```

```{r}
# Title match against CASE
dup_a <- cordis.projects$title[!duplicated(cordis.projects$title)]
dup_b <- ca.Df$Name[!duplicated(ca.Df$Name)]

generics::intersect(str_to_lower(dup_a),
                    str_to_lower(dup_b)) %>% length() # 166 project matches.
```

```{r}
new.CASE <- ca.Df

colnames(new.CASE)[16] <- "id"
colnames(new.CASE)[3] <- "title"
colnames(new.CASE)[18] <- "start_date"
colnames(new.CASE)[19] <- "end_date"

# Exact matching.
cordis.match.A <- new.CASE %>%
  dplyr::inner_join(cordis.projects, by = "title",keep = T) %>%
  filter(!duplicated(title.x)) # 161 project matches.


# Fuzzy matching function is sensitive to NA values.
new.CASE <- new.CASE[!is.na(new.CASE$title),]
# sum(is.na(new.CASE$title))

# Fuzzyjoin package function is more efficent. (173 project matches)
cordis.match.B <- new.CASE %>%
  stringdist_inner_join(cordis.projects, by = "title", max_dist = 1)

cordis.match.C <- new.CASE %>%
  stringdist_inner_join(cordis.pbd, by = "title", max_dist = 1)

# Print results.
cordis.match.A %>%
  dplyr::select(title.x,title.y,id.y) %>%
  slice_head(n = 10)

# How about sweCris against corids?
cordis.match.D <- sw.Df %>%
  dplyr::mutate(ProjectTitleEn = str_to_lower(ProjectTitleEn)) %>%
  dplyr::mutate(ProjectTitleEn = str_trim(ProjectTitleEn)) %>%
  dplyr::mutate(ProjectTitleEn = str_remove_all(ProjectTitleEn,
                                                "[^[:alnum:][:space:]']")) %>%
  dplyr::inner_join(cordis.projects %>%
                    dplyr::mutate(title = str_to_lower(title)) %>%
                    dplyr::mutate(title = str_trim(title)) %>%
                    dplyr::mutate(title = str_remove_all(
                      title,"[^[:alnum:][:space:]']")),
                    by = c(ProjectTitleEn = "title"), keep = T)
```

## Section summary --- Cordis vs Case

## OpenAIRE

```{r cache=TRUE,eval=TRUE,results='hide'}
utils::globalVariables(".")

# https://graph.openaire.eu/develop/api.html#projects

openaire_search <- function(
    countries = "se",
    acronyms = "KTH",
    page = 1,
    page_size = 10,
    format = c("xml", "json", "csv", "tsv")) {

  ct <- switch(match.arg(format), xml = httr::content_type_xml(),
    json = httr::content_type_json(), httr::content_type("text/plain"))

  httr::GET("https://api.openaire.eu/search/projects", query = list(
    page = page,
    size = page_size,
    participantCountries = countries,
    participantAcronyms = acronyms,
    format = format
  ), ct)

}

#' Projects given an acronym
#' @param countries the countries to filter by, comma-separated string of 2-letter ISO country codes, by default "SE"
#' @param acronyms the acronyms to filter by, whitespace-separated string, by default "KTH"
#' @import readr
#' @export
openaire_projects <- function(
    countries = "se",
    acronyms = "KTH") {

  openaire_search(countries, acronyms, format = "tsv", page_size = 1000) %>%
    suppressWarnings() %>%
    httr::content(show_col_types = FALSE)
}

#openaire_projects() %>% View()


or_na <- function(x)
  ifelse(length(x) == 1 && !purrr::is_null(x), x, NA_character_)

openaire_as_tibble <- function(...) {

  res <- openaire_search(..., format = "xml")  %>%
    httr::content()

  header <-
    xml2::xml_find_all(res, ns = xml2::xml_ns(res), "/response/header")

  query <- header %>% xml2::xml_find_all("query") %>% xml2::xml_text()
  page <- header %>% xml2::xml_find_all("page") %>% xml2::xml_text()
  n_pages <- header %>% xml2::xml_find_all("total") %>% xml2::xml_text()

  message(glue::glue("Using query {query}."))
  message(glue::glue("Found {n_pages} pages, currently on page  {page}"))

  # TODO implement paging!

  meta <-
    xml2::xml_find_all(res, ns = xml2::xml_ns(res), "/response/results/result")

  projects <- meta %>% xml2::xml_find_all("metadata/oaf:entity/oaf:project")

  projects %>% xml2::xml_find_all(".")

  fetch <- function(x, xpath)
    x %>% xml2::xml_find_all(xpath) %>% xml2::xml_text() %>% or_na()

  projects %>% purrr::map_dfr(.f = function(x) tibble::tibble(
    code = x %>% fetch("code"),
    project_title = x %>% fetch("title"),
    beg_date = x %>% fetch("startdate"),
    end_date = x %>% fetch("enddate"),
    duration = x %>% fetch("duration"),
    ec_art_293 = x %>% fetch("ecarticle29_3"),
    oa_is_mandated = x %>% fetch("oamandatepublications"),
    ec_sc_39 = x %>% fetch("ecsc39"),
    summary = x %>% fetch("summary"),
    collected_from = x %>% fetch("collectedfrom/@name"),
    currency = x %>% fetch("currency"),
    cost = x %>% fetch("totalcost"),
    funded_amount = x %>% fetch("fundedamount")
  ))
}


#openaire_as_tibble(page_size = 10)


openaire_search_crawl <- function() {

  page_size <- 50

  res <- openaire_search(format = "json", page_size = page_size) %>% httr::content()

  n <- res$response$header$total$`$`
  stopifnot(page_size == res$response$header$size)
  needs_crawl <- n > page_size

  if (needs_crawl) {

    n_pages <- n %/% page_size + ifelse(n %% page_size > 0, 1, 0)
    i <- 1:(n_pages)
    calls <- sprintf("openaire_search(format = 'json', page = %s, page_size = %s)", i, page_size)
    calls <- paste0(calls, " %>% httr::content()")
    message(sprintf("Fetching %s hits in %s batches of %s records", n, n_pages, page_size))

  }

  pb <- progress::progress_bar$new(
    format = "  downloading [:bar] :percent in :elapsed",
    total = n_pages, clear = FALSE, width= 60)

  call2df <- function(x) {
    pb$tick()
    Sys.sleep(0.01)
    force(rlang::eval_tidy(rlang::parse_quo(x, env = rlang::current_env()))) #%>%
    #as.data.frame() %>%
    #tibble::as_tibble() %>%
    #dplyr::select_if(function(y) !is.list(y))
  }

  batch <- calls %>% purrr::map(call2df)

  parse_results <- function(x) {
    x$response$results$result$metadata %>%
      as.data.frame() %>%
      tibble::as_tibble() %>%
      dplyr::select_if(function(y) !is.list(y))
  }

  content <- batch %>% purrr::map(parse_results)

  batch[[1]]$response$results$result %>%
    purrr::map_dbl(list("metadata", "oaf:entity", "oaf:project", "totalcost", "$"), .default = NA_real_)

  batch[[1]]$response$results$result[1] %>% purrr::map(function(x) tibble::tibble(
    totalcost = purrr::map_chr(x, list("metadata", "oaf:entity", "oaf:project", "totalcost", "$"), .default = NA_real_)
    )) %>%
    purrr::map("totalcost")#names)

  return(res)
}
```
