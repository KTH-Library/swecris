---
title: "Swecris/Case Project 2022-2023"
author: "Mohamad Bazzi"
date: "2022-11-11"
output: html_document
editor_options: 
  chunk_output_type: console
---

### Summary

Explore the possibility of enriching CASE data from sweCris. Enhance existing information by supplementing missing or incomplete data.

<https://github.com/KTH-Library/bibliotools>
<https://rubular.com/>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Libraries**
```{r warning=FALSE, message=FALSE}
R.packages <- c("devtools","bibliotools","dplyr","swecris","kthapi","grid","gridExtra","skimr","stringdist",
                "ReDaMoR","gt","janitor","parallel","ggplot2","DiagrammeR","ggpubr","purrr","ktheme","RecordLinkage",
                "magrittr","rjson","VennDiagram","cld2","fuzzyjoin","naniar","furrr","stringr","qpcR")

lapply(R.packages, require, character.only = TRUE)
```

## **sweCris/Case data cleaning and pre-processing**

```{r}
# All sweCris project, not limited to KTH associated.
swe.Total <- swecris_fundings()
# Summary statistics.
skimr::skim(swe.Total)
```

```{r}
# SweCris data
swecris::swecris_kth |> str(vec.len = 1)
swecris::swecris_kth |> names()
swecris::swecris_kth |> slice_head(n=5)

sw.Df <- swecris::swecris_kth

# Re-format: Convert into 6 columns. Some strings are erroneous (e.g., Sex, male where it should be female or vice versa)
# Swcris Project ID,
# Name (first & last),
# Orcid ID
# Role (PI or Co-investigator in English)
# Role (PI or Co-investigator in Swedish)
# Sex

# Define rule by which to structure the strings. More than one project might be associated 
sw.Df %>% View()
sw.Df$InvolvedPeople[[3]]
sw.Df$ProjectTitleEn[[3]]
sw.Df$FundingOrganisationTypeOfOrganisationEn[[3]]
sw.Df$FundingOrganisationNameEn[[3]]
sw.Df$ProjectId[[3]] # "2021-00527_Formas"

#'@ The string is randomly arranged i.e. the co-investigator(s) may show up first, followed by the Principal Investigator.
#'@ Endless variation to how these appear. Duplicates are common and the occasional string will miss information.

#'@ Avoid getting bogged down, proceed to pull unique Names and Orcid Id's instead.
#'@ Not all authors have an ORCID ID.
#'
# Example.
as.character(sw.Df$InvolvedPeople[[3]]) %>% cat()
gsub(pattern = "¤",replacement = " ",x = as.character(sw.Df$InvolvedPeople[[3]]))
strsplit(gsub(pattern = "¤",replacement = ",",x = as.character(sw.Df$InvolvedPeople[[3]]),fixed = T),",\\s*") %>% unlist() %>% unique()
unlist(strsplit(x = sw.Df$InvolvedPeople[[3]], "¤"))[-c(1:3)] # remove the first three elements (these are empty)

# Try separate name by project role (i.e. co and principal investigator)
# Use the ¤¤¤ symbol as a point of demarcation (i.e. extract sub-string)
unlist(strsplit(x = sw.Df$InvolvedPeople[[5]], "¤"))[-c(1:3)] %>% as.data.frame()

strsplit(sw.Df$InvolvedPeople[[1]],"¤")[[1]]
strsplit(sw.Df$InvolvedPeople[[1]],"¤")[[1]][-c(1:3)][2]
strsplit(sw.Df$InvolvedPeople[[1]],"¤")[[1]][-c(1:3)][4-2]
```

```{r}
# CASE data.
ca.Df <- bibliotools::case()
# Adjust column names
colnames(ca.Df)[16] <- "ProjectNumber"
colnames(ca.Df)[14] <- "PrimaryResearcher"
colnames(ca.Df)[6] <- "FundingOrganisation"
```

## **Matching keys**

+ $sweCris (ProjectId) \Leftrightarrow CASE (ProjectNumber)$
+ $sweCris (FundingOrganisationNameSv) \Leftrightarrow CASE (`Funding Organisation`)$
+ $sweCris (InvolvedPeople: nested as part of annoying string) \Leftrightarrow CASE (Primary Researcher [Name] & Role)$
+ $sweCris (ProjectTitleEn) \Leftrightarrow CASE (Name: languagespecification for project titles are inconsistent)$
+ $sweCris (ProjectEndDate) \Leftrightarrow CASE (end)$
+ $sweCris (ProjectStartDate) \Leftrightarrow CASE (beg)$

  External key.
+ $ Bucket objects with Orcid ID and KTH username \Leftrightarrow CASE (username)$

> 1A. Key: Project number (# 1.1. Exact matches on ID)

**Project number** in CASE is the same as **Project ID** in sweCris But these have to be slightly re-formatted to match those in CASE.
In sweCris the ID form/style is consistently written, unlike CASE. Adopted the sweCris style for CASE entries.

```{r}
# 1. Subset CASE by Funding Organisation = Swedish Energy Agency.
sea.ca <- subset(ca.Df, FundingOrganisation == "Energimyndigheten")
# 2. Remove NA and superfluous text.
sea.ca <- sea.ca[!is.na(sea.ca$ProjectNumber),]
sea.ca <- sea.ca[sea.ca$ProjectNumber %in% as.vector(na.omit(sea.ca$ProjectNumber[sapply(sea.ca$ProjectNumber, nchar) == 7])),]
# 3. Add P to number strings.
sea.ca$ProjectNumber <- paste0("P", gsub("","",sea.ca$ProjectNumber))
# 4. Add organisation name to string.
sea.ca$ProjectNumber <- paste(sea.ca$ProjectNumber,"_Energi")
sea.ca$ProjectNumber <- gsub("\\s","", sea.ca$ProjectNumber)
# 5. Repeat: Keep numbers only)
ca.Df["clean.IDA"] <- gsub("[^0-9.-]","",ca.Df$ProjectNumber)
# 6. Keep 10 character elements only.
ca.Df.sub <- ca.Df[ca.Df$clean.IDA %in% as.vector(na.omit(ca.Df$clean.IDA[sapply(ca.Df$clean.IDA, nchar) == 10])),] # 270 observations.
ca.Df.sub$clean.IDA <- gsub("^-","",ca.Df.sub$clean.IDA)
# 7. Remove empty funding organisation.
ca.Df.sub$FundingOrganisation[ca.Df.sub$FundingOrganisation == "Not Applicable N/A"]  <- ""
# 8. Standardize against sweCris names.
ca.Df.sub$FundingOrganisation <- recode(ca.Df.sub$FundingOrganisation,
                                         Energimyndigheten = "Energi",
                                         VINNOVA = "Vinnova",
                                         Vetenskapsrådet = "VR")
# 9. Combine
ca.Df.sub["clean.IDA"] <- paste(ca.Df.sub$clean.IDA,ca.Df.sub$FundingOrganisation,sep = "_")
ca.Df.sub["clean.IDA"] <- gsub("^-","",ca.Df.sub$clean.IDA)
# 10. Combine dataframes.
cleanID.CASE <- rbind(sea.ca,ca.Df.sub) # 348 observations.
cleanID.CASE[1:78,"clean.IDA"] <- cleanID.CASE[1:78,"ProjectNumber"]

# 11. How many in 00000-0_ZZ shape in sweCris? They are all Energy funded 
as.vector(na.omit(str_extract(sw.Df$ProjectId, "(\\d+)-(\\d{1})_[:alpha:]+"))) %>% length() # 369 (11.76%)
# 12. How many in 0000-00000_ZZ format?
as.vector(na.omit(str_extract(sw.Df$ProjectId, "(\\d+)-(\\d{5})_[:alpha:]+"))) %>% length() # 2680 (85%). In total with the aforementioned = 96.76%
# 13. How many in P00000-0_ZZ format? These are also Energy Funded. This is the same as 00000-0_ZZ.
as.vector(na.omit(str_extract(sw.Df$ProjectId, "([:alnum:]+)-(\\d{1})_[:alpha:]+"))) %>% length() # same as the first one.
```

**Note**

1. Feedback to CASE: The project number field would benefit from a re-structuring and consistent ID format designation across projects.
2. Cleaning, using a three-step process: 
  + i) removal of all non-numeric characters
  + ii) retaining all 9 digits + hyphen elements (this is the conventional label shape in sweCris).
  + iii) add funding organisation to CASE ID.

3. There are at least **8** different ID styles in sweCris: 
  + i) **00/00_ZZ**
  + ii) **000/00_ZZ**
  + iii) **P00-000_ZZ**
  + iv) **00/00 Z_ZZ**
  + v) **P00000-0_ZZ**
  + vi) **000/00ZZ_ZZ**
  + vii) **000/00 Z_ZZZZ**
  + viii) **0000-00000_ZZ** (majority class: 85%).
  
  **P00000-0_ZZ** is the second most prevalent format, and all are **Swedish Energy Agency** affiliated. 
    Together they make up 96.76% of all ID patterns in sweCris.

4. In CASE, project ID's associated with **Swedish Energy Agency** often lack the initial *P* letter.
   Furthermore, many don't have an ID, some have more than one ID along with text, and some are just text.

```{r}
# Remove any character after underscore. This should now match with the CASE style. 
# sw.Df$ProjectId <- gsub(pattern = "\\_.*", "", sw.Df$ProjectId)

# Remove any letters from the ID. Limited solely to number-sequences.
# sw.Df$ProjectId <- gsub("[^0-9.-]", "", sw.Df$ProjectId)

# Subset CASE data (both NA's and duplicates in Project Number are removed)
cleanID.CASE <- cleanID.CASE %>%
  filter(!duplicated(clean.IDA)) %>%
  filter(!duplicated(Name)) # 346 projects.

# Confirm. Looks fine.
which(duplicated(x = cleanID.CASE$Name) == T)
which(duplicated(x = cleanID.CASE$clean.IDA) == T)

# How many ID's match?
generics::intersect(cleanID.CASE$clean.IDA,sw.Df$ProjectId) %>% length() # 123 projects match. This approach might be to stringent. Attempt fuzzy or other methods of matching.
# Initial match. This will add information to those project that match between the datasets.
Match.1 <- cleanID.CASE %>%
  left_join(sw.Df, by = c("clean.IDA" = "ProjectId")) # adds 27 more variables. Check their level of completeness.

# Parse out the projects that matched.
MissCheck.1 <- Match.1[Match.1$clean.IDA %in% generics::intersect(cleanID.CASE$clean.IDA,sw.Df$ProjectId), ]
MissCheck.1 <- MissCheck.1 %>% mutate(across(c("ProjectTitleSv","ProjectTitleEn","ProjectAbstractSv","ProjectAbstractEn"), na_if, "Unknown"))
MissCheck.1 %>% nrow()

MissCheck.1 %>%
  group_by(FundingOrganisation) %>%
  summarise(n = n()) %>%
  arrange(-n)

# Degree of missingness?
sapply(MissCheck.1[,41:68], function(x) sum(is.na(x)))
# 9. Visualize.
MissCheck.1[,41:68] %>% 
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(aspect.ratio = 1)

dev.off()
```

- **Bring up during next session**
  1) The number of project matches depend on how ID standardization is done.
     Using the two predominant ID styles in sweCris (see above) as a reference, I managed to find 124 distinct project matches.
     
  2) Generally, most CASE ID's are inconsistently written, which makes it very difficult to merge against sweCris.
     The issue is further exacerbated by variable ID formats in sweCris. But is generally better than CASE.
  
  3) Of the **346** CASE projects with a clean ID, only *35% (N=124)* could be matched with sweCris projects.
  
  4) Viewed altogether, only *5.09%* of *unique CASE projects (N=2434)* could be detected in sweCris using *project ID* as an identifier.
     
  5) The **Project Title** variable in CASE have also repeated occurrences (i.e. duplicates).
     **I have removed these, but is this a known data-set pathology? Ask the gents**
     
  6) Overall, despite the low number of project matches, the added information retrieved via sweCris is rather complete (column-wise)[show-graph!].
     This is unsurprising as the data quality in sweCris tends to be better.
     
  7) How many columns are redundant?

```{r}
## Venn diagram showing project overlap based on project ID's.
mP1 <- draw.pairwise.venn(area1= 3137,area2 = 2434,
                          cross.area = 124,
                          category   = c("sweCris projects with an ID", "CASE projects with an ID"),
                          fill = c("grey80","darkcyan"),
                          scaled = T,cex = 1,rotation.degree = 45)
dev.off()
```

    > area1 = the total number of unqiue project ID in sweCris.
    > area2 = the total number of unique project number is CASE with a similar ID format.

> 1B. Key: Project number (# 1.2. In-exact matches on ID)

```{r}
# Fuzzy matching. The Levenshtein distance ... 
Fuzz.ID <- cleanID.CASE %>%
  stringdist_inner_join(x = sw.Df,by = c(ProjectId = "clean.IDA")) %>%
  filter(!duplicated(clean.IDA)) %>%
  filter(!duplicated(Name)) # 303 matches?

Fuzz.ID["lev"] <- lev <- RecordLinkage::levenshteinSim(Fuzz.ID$clean.IDA,Fuzz.ID$ProjectId)

slice_head(Fuzz.ID[,c("clean.IDA","ProjectId","lev")],n = 10)
# Miss-Classification rate.
100-(which(Fuzz.ID$lev == 1.0000000) %>% length()/(length(Fuzz.ID$lev)))*100 # ridiculous
```

> 2. Key: Project Title.

```{r}
# How many NA projet titles are there in sweCris?
sum(is.na(sw.Df$ProjectTitleSv)) # None.
sum(is.na(sw.Df$ProjectTitleEn)) # None.
```

```{r}
# Add
ca.Df["language"] <- NA
# Language identifier
system.time(
  for(i in 1:length(ca.Df$Name)) {
  ca.Df$language[[i]] <- tolower(cld2::detect_language(text = ca.Df$Name[[i]],
                                                       plain_text = T,lang_code = F))
}
)

# Correct
ca.Df$language[ca.Df$language == "norwegian"] <- "swedish"
# Summary.
ca.Df %>%
  group_by(ca.Df$language) %>%
  count(sort = T) %>%
  print(n=45)

# Unknowns, are a mix of Swedish & English titles.
ca.Df$language[is.na(ca.Df$language)] <- "Unknown"
# Other languages?
ca.Df %>% group_by(Name,language) %>% select(Name,language) %>%
  filter(language == "welsh" | language == "uzbek" | 
         language == "turkish" | language == "portuguese" |
         language == "nyanja" | language == "kurdish" |
         language == "indonesian" | language == "hungarian" |
         language == "galician" | language == "croatian" |
         language == "catalan" | language == "albanian" |
         language == "afrikaans" | language == "spanish" |
         language == "kinyarwanda" | language == "ganda" |
         language == "estonian" | language == "basque" |
         language == "german") %>% 
  print(n = 27)
```

*Note*

The main problem with matching with Project Title is that CASE does not provide the information in a consistent format/language.

```{r}
# Subset based on intersection.
# Remove extra spaces and use case-folding to improve intersection.
merge.titles <- c(generics::intersect(x = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT")),
                                      y = gsub("\\s+"," ",iconv(tolower(na.omit(sw.Df$ProjectTitleSv)),to = "ASCII//TRANSLIT"))),
                  generics::intersect(x = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT")),
                                      y = gsub("\\s+"," ",iconv(tolower(na.omit(sw.Df$ProjectTitleEn)),to = "ASCII//TRANSLIT"))))
# Any duplicates? Yes.
duplicated(merge.titles)
# Remove.
merge.titles <- unique(merge.titles) # 136. Although not that good, this is still better than project ID.
# Subset
sub.ca.Df.2 <- ca.Df
sub.ca.Df.2$Name <- gsub("\\s+"," ",iconv(tolower(ca.Df$Name),to = "ASCII//TRANSLIT"))

sub.ca.Df.2 <- sub.ca.Df.2[sub.ca.Df.2$Name %in% merge.titles, ]
sub.ca.Df.2$Name[duplicated(sub.ca.Df.2$Name)]

# Ask the team about this? For now, assume its a true duplicate.
sub.ca.Df.2[sub.ca.Df.2$Name == "innovativ energi- och effekteffektiv värmepump för småhus", ] %>% View()
sub.ca.Df.2[sub.ca.Df.2$Name == "kundinvolvering vid prissättning av digitala erbjudanden", ] %>% View()
# Clean
sub.ca.Df.2 <-
  sub.ca.Df.2 %>%
  group_by(Name) %>%
  filter(!duplicated(Name))

nrow(sub.ca.Df.2)

# sweCris modification to enable inner-join.
modify.sw.Df <- sw.Df
modify.sw.Df$ProjectTitleSv <- gsub("\\s+"," ",iconv(tolower(sw.Df$ProjectTitleSv),to = "ASCII//TRANSLIT"))
modify.sw.Df$ProjectTitleEn <- gsub("\\s+"," ",iconv(tolower(sw.Df$ProjectTitleEn),to = "ASCII//TRANSLIT"))

# Merge in a two step fashion.
parseSwe <- ca.Df %>%
  filter(!is.na(Name)) %>%
  mutate(Name = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT"))) %>%
  group_by(Name) %>% 
  filter(!duplicated(Name)) %>% 
  inner_join(modify.sw.Df, by = c("Name" = "ProjectTitleSv"))
  # distinct(Name)

parseEng <- ca.Df %>%
  filter(!is.na(Name)) %>%
  mutate(Name = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT"))) %>%
  group_by(Name) %>% 
  filter(!duplicated(Name)) %>% 
  inner_join(modify.sw.Df, by = c("Name" = "ProjectTitleEn"))
  # distinct(Name)

# Match by project title enrichment.
Match.2 <- rbind(parseSwe,parseEng)
Match.2 <- Match.2 %>% 
  filter(!duplicated(Name))
```

```{r}
## Venn diagram showing projects overlap based on project title.
mP2 <- draw.pairwise.venn(area1= 3137,area2 = 2434,
                          cross.area = 136,
                          category   = c("SweCris-titled projects", "CASE-titled projects"),
                          fill = c("grey80","darkcyan"),
                          scaled = T,cex = 1,rotation.degree = 45)
dev.off()
```

    > area1 = represent unique project ID in sweCris, instead of project titles. This is becuase the length of unique title differ between the Swedish and English title.
    > area2 = reprent unqiue project name (i.e. title) in CASE.

```{r}
ggarrange(mP1,mP2) + theme(aspect.ratio = 1/2)
dev.off()
```

```{r}
Match.2[,41:69] %>%
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(aspect.ratio = 1)

dev.off()
```

**Are the projects the same as when using ID vs Title?**
```{r}
generics::intersect(gsub("\\s+"," ",iconv(tolower(na.omit(MissCheck.1$Name)),to = "ASCII//TRANSLIT")),Match.2$Name)
generics::setdiff(gsub("\\s+"," ",iconv(tolower(na.omit(MissCheck.1$Name)),to = "ASCII//TRANSLIT")),Match.2$Name)

Total.M1 <- merge(MissCheck.1,Match.2,all = T)
Total.M1$Name <- iconv(tolower(Total.M1$Name),to = "ASCII//TRANSLIT")
# Subset.
Total.M1 <- Total.M1 %>%
  filter(!duplicated(Name))

# Together ID and Project Title provide a 189 project match with sweCris.
```

74 projects are the same. In other words, the project match depend to some extent on the identifier being used. Could be simply a reflection of inconsistent ID formats.

> 3. Key: Primary Researcher

The **InvolvedPeople** column have a complex string structure with relevant information that ought to be parsed out to facilitate maximum matching with the CASE database.

The main problem here is that the name of the project leaders, including participating researchers are bind into poorly structured text strings. To circumvent this "minor" predicament, I have attempted to parse out **name** and **role** based on their general position in each string. (see above).

```{r}
grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[1]],"¤")[[1]][-c(1:3)])
grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[1]],"¤")[[1]][-c(1:3)])[1] # In normal scenarios it's always the fourth's position in the string.
grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[20]],"¤")[[1]][-c(1:3)])[1] # or, as in this example it's the 20th position.
grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[20]],"¤")[[1]][-c(1:3)])[1]-2 # Position of PI name.

 # Here is the name.
strsplit(sw.Df$InvolvedPeople[[20]],"¤")[[1]][-c(1:3)][18]

sw.Df['PrimaryResearcher'] <- NA
sw.Df['Leading.Role'] <- NA

# Generalize.
for(i in 1:length(sw.Df$InvolvedPeople)) {
  # Index.
  iX <- strsplit(sw.Df$InvolvedPeople[[i]],"¤")[[1]][-c(1:3)]
  # Attain name via PI position
  sw.Df$PrimaryResearcher[[i]] <- iX[grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[i]],"¤")[[1]][-c(1:3)])[1]-2]
  # Clean names, with no extra spaces.
  sw.Df$PrimaryResearcher[[i]] <- gsub("\\s+"," ",sw.Df$PrimaryResearcher[[i]])
  # Remove accents.
  # sw.Df$PrimaryResearcher[[i]] <- iconv(sw.Df$PrimaryResearcher[[i]],to = "ASCII//TRANSLIT")
  # Role.
  sw.Df$Leading.Role[[i]] <- iX[grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[i]],"¤")[[1]][-c(1:3)])[1]]
}

# Summarize.
sw.Df %>% group_by(Leading.Role) %>% count() # 696 missing. how come?
# Subset to retain all NA.
sw.Df[is.na(sw.Df)] <- "Unknown"
sw.Df.Unknown <- subset(sw.Df,(Leading.Role %in% "Unknown"))
# Rows (n=14) were Involved People have limited information, but not Principal Investigator.
string.InNA <- c(215,270,278,324,402,405,444,447,505,509,530,572,605,606)
sw.df.Partial <- sw.Df.Unknown[string.InNA, ]
```

```{r}
parse_involved_people()
```

**NB** 

sweCris's *Involved People* column contains information on 2441 Principal Investigators (71.81%).
Only 14 of the remaining 696 projects have rudimentary information and are limited to co-investigators. As for the rest (i.e. 682 projects), no information has been collected about involving people.

```{r}
# Number of roles.
sw.Df %>%
  group_by(Leading.Role) %>%
  summarise(n = n())

# Remove accent from names.
# ca.Df$PrimaryResearcher <- iconv(ca.Df$PrimaryResearcher,to = "ASCII//TRANSLIT")

# How many matches?
generics::intersect(na.omit(ca.Df$PrimaryResearcher),na.omit(sw.Df$PrimaryResearcher)) %>% unique() # 372 exact name matches. Better than ID and Project title combined.

# Match: problem here is that name matching might be insufficient: N = 587 unique project?
Match.3 <- ca.Df %>% 
  inner_join(sw.Df, by = c("PrimaryResearcher" = "PrimaryResearcher")) %>%
  filter(!is.na(PrimaryResearcher)) %>%
  filter(!duplicated(Name)) %>% 
  filter(!duplicated(ProjectNumber)) # Remove duplicated project titles, project numbers, and NA's on primary researcher. Am I missing anything here?

UnMatched.3a <- anti_join(ca.Df,sw.Df, by="PrimaryResearcher") # 1070 Projects by PR don't match.

# However an author may be PI on multiple projects. So how many projects are there in total?
# How many projects are associated with each leading researcher?
Match.3 %>% group_by(PrimaryResearcher) %>%
  count(sort = T)

# Plot
Match.3 %>% group_by(PrimaryResearcher) %>%
  count(sort = T) %>% 
  ggplot(aes(x=PrimaryResearcher, y=n)) +
         geom_bar(stat="identity") +
  theme_bw() +
  geom_text(aes(label=PrimaryResearcher,colour=PrimaryResearcher),
            vjust = -0.5, hjust = -0.5, size = 3,
            position = position_dodge(0.9),angle=90,show.legend = F) +
  theme(axis.ticks = element_blank(),
        axis.text = element_blank())

dev.off()

# Level of completeness? (CASE)
Match.3[,1:41] %>% 
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(aspect.ratio = 1)

dev.off()
# (sweCris)
Match.3[,42:67] %>% 
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(aspect.ratio = 1)
```

*NB*

1. 371 exact name matches. Better than ID and Project title combined. But this is probably an underestimation anyway. The complete name may not include 'middle names' in CASE.

2. In total 587 unique projects are matched between CASE and sweCRis using Primary Researcher as a key. 


```{r}
## Venn diagram showing projects overlap based on project title.
mP3 <- draw.pairwise.venn(area1= 3137,area2 = 1623,
                          cross.area = 587,
                          category   = c("SweCris: Primary Researcher", "CASE: PrimaryResearcher"),
                          fill = c("grey80","darkcyan"),cat.col = "black",cat.cex = 1,
                          scaled = T,cex = 1,rotation.degree = 45)
dev.off()
```

    > Number of unique project numbers for each primary researcher shown against its reciprocal in CASE.
    > Minimum of 587 matches. Better than ID and Project title combined

```{r}
ggarrange(mP1,mP2,mP3) + theme(aspect.ratio = 1/2)
dev.off()
```

```{r}
# Combine ID, Title, and Primary Research
Total.M2 <- merge(Total.M1,Match.3,all = T)
Total.M2$Name <- tolower(iconv(Total.M2$Name,to = "ASCII//TRANSLIT"))
Total.M2 <- Total.M2 %>%
  filter(!duplicated(Name)) # 675 unique projects in total.

Total.M2 %>% View()
```

> 4. External Key: OrcID

```{r}
# Data variables.
ug <- readr::read_csv(rawToChar(kthcorpus::minio_get("ug_kthid_orcid.csv",bucket = "kthcorpus"))) # ugkthId & Orcid
lookup <- readr::read_csv(rawToChar(kthcorpus::minio_get("ug_kthid_unit.csv", bucket = "kthcorpus"))) # unique ugkthId
```

```{r}
# Merge by username and remove incomplete cases (subset by ugOrcid)
exDf.ca <- ca.Df %>%
  left_join(lookup, by = c("username" = "ugUsername")) %>%
  filter(!is.na(ugOrcid)) %>%
  filter(!duplicated(ProjectNumber)) %>%
  filter(!duplicated(Name)) # 833 unique projects

NROW(exDf.ca) # 832 projects.
sapply(exDf.ca[c("ProjectNumber","Name")],function(x) duplicated(x))

# Return mismatches.
janitor::compare_df_cols(exDf.ca,sw.Df,return = "mismatch", bind_method = "rbind")
```

**Call sweCris api to get result from a web service**

```{r}
# Can we match by ORCiD?
# Function to look-up projects from SweCRIS via ORCiD.
swecris_projects_from_orcid <- function(orcid) {

  route <-
    sprintf(
      paste0("https://swecris-api.vr.se",
             "/v%s/projects/persons/orcId/%s")
      , 1, URLencode(orcid)
    )

  res <- swecris:::swecris_get(route)

  fields <- c(
    "projectId",
    "projectTitleSv",
    "projectTitleEn",
    "projectAbstractSv",
    "projectAbstractEn",
    "projectStartDate",
    "projectEndDate",
    "coordinatingOrganisationId",
    "coordinatingOrganisationNameSv",
    "coordinatingOrganisationNameEn",
    "coordinatingOrganisationTypeOfOrganisationSv",
    "coordinatingOrganisationTypeOfOrganisationEn",
    "fundingOrganisationId",
    "fundingOrganisationNameSv",
    "fundingOrganisationNameEn",
    "fundingOrganisationTypeOfOrganisationSv",
    "fundingOrganisationTypeOfOrganisationEn",
    "fundingsSek",
    "fundingYear",
    "fundingStartDate",
    "fundingEndDate",
    "typeOfAwardId",
    "typeOfAwardDescrSv",
    "typeOfAwardDescrEn")

  projects <-
    res %>%
    purrr::map_df(.f = function(x) x[fields] %>% as_tibble())

  peopleList <-
    res %>%
    purrr::map_df(.f = purrr::pluck(c("peopleList")))
  
  scbs <-
    res %>%
    purrr::map_df(.f = purrr::pluck(c("scbs")))

  list(projects = projects, peopleList = peopleList, scbs = scbs)

}

# Slow and sub-optimal solution.
detectCores()
doParallel::registerDoParallel()
res <- list(map(exDf.ca$ugOrcid[1:832],
                purrr::safely(swecris_projects_from_orcid)))

View(res)

# Pick one ORCiD from a CASE-project, what does SweCRIS provide?
cazeD <- exDf.ca$ugOrcid[1] %>% swecris_projects_from_orcid() # Peter Hedström ,returns a list with 3 dataframes.
cazeD[[1]] %>% View() # Returns all the projects that are associated with this unique orcidID including the project specific role.
cazeD[[2]] %>% View()
cazeD[[3]] %>% View()

cazeD[[2]] %>%
  filter(fullName == "Peter Hedström") %>%
  ggplot() +
  geom_bar(aes(x = fullName)) +
  # scale_y_continuous(breaks = 1:X) +
  facet_wrap(.~roleEn, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 45,size = 5,vjust = 0.8))

cazeD[[2]] %>% group_by(fullName,roleEn) %>% count(sort = T)

# I guess this counts all people involved in a given project and their respective role. 
# How many projects do this correspond to?
res <- mclapply(exDf.ca$ugOrcid[1:4], swecris_projects_from_orcid)
```
This seems most promising so far.
