---
title: "Swecris/Case data assessment"
author: "Mohamad Bazzi"
highlight-style: pygments
format:
  html: 
    code-fold: true
    html-math-method: katex
    embed-resources: true
  pdf:
    geometry: 
      - top=30mm
      - left=30mm
  docx: default
---

## Summary

Goal: To enhance existing information in CASE by supplementing missing or incomplete data.

```{r message=FALSE,warning=FALSE,results='hide',echo=TRUE}
R.packages <- c("devtools","bibliotools","dplyr","swecris","kthapi","grid",
                "gridExtra","skimr","stringdist","knitr","quarto","ggfittext",
                "ReDaMoR","gt","janitor","parallel","ggplot2","DiagrammeR",
                "ggpubr","purrr","ktheme","RecordLinkage","flextable",
                "magrittr","kableExtra","VennDiagram","cld2",
                "fuzzyjoin","naniar","furrr","stringr","qpcR","dlookr","xlsx")

lapply(R.packages, library, character.only = TRUE)
```

## Data sources

```{r message=FALSE,echo=TRUE,results='hide'}
# All sweCris project, not limited to KTH associated.
swe.Total <- swecris_fundings()
# Summary statistics.
skimr::skim(swe.Total)
# sweCris data (KTH only)
sw.Df <- swecris::swecris_kth
# CASE data.
ca.Df <- bibliotools::case()
# Adjust column names.
colnames(ca.Df)[16] <- "ProjectNumber"
colnames(ca.Df)[14] <- "PrimaryResearcher"
colnames(ca.Df)[6] <- "FundingOrganisation"
```

```{r echo=TRUE,out.width="50%",fig.cap="Figure 1. Data-driven flowchart (matching keys)."}
include_graphics("Figure-1.png")
```

## CASE data-quality

```{r echo=TRUE, fig.cap="Figure 2. Pareto chart for missing values (counts and proportions) in CASE."}

dlookr::plot_na_pareto(x = ca.Df, col = "blue",typographic = T) + 
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

### CASE data-quality by school

```{r out.width="100%", fig.cap="Figure 3. Pareto chart for missing values by school in CASE."}
# School data-frame.
ca.school <- ca.Df
ca.school$school_short <- as.factor(ca.school$school_short)
# Split data-frame by factor.
school <- ca.school %>% 
  group_by(school_short)

split.school <- group_split(school)
# Droplevels.
for(i in seq_along(split.school)) {
  split.school[[i]]$school_short <- droplevels(split.school[[i]]$school_short)
}
# Set title names.
schoolName <- c("ABE","CBH","EECS","ITM","SCI")
# Plot.
ls.plot <- list()
for(i in seq_along(split.school)) {
  out <- split.school[[i]] %>% 
    plot_na_pareto(col = "blue",typographic = T,main = schoolName[i]) +
    theme(axis.text.x = element_text(size = 3),
          axis.text.y = element_text(size = 3),
          axis.title.x = element_text(size = 3),
          axis.title.y = element_text(size = 3),
          axis.title.y.right = element_text(size = 3),
          plot.title = element_text(size=7),
          legend.title = element_text(size = 4),
          legend.text = element_text(size = 4),
          legend.key.size = unit(.5,"mm"),
          legend.key.height= unit(.5, 'mm'),
          legend.key.width= unit(.5, 'mm'),
          plot.margin=unit(c(-0.5,1,1,1), "mm"))
  ls.plot[[i]] <- out
}

do.call("grid.arrange", c(ls.plot, ncol=3))
```

## sweCris data-quality

```{r echo=TRUE, fig.cap="Figure 4. Pareto chart for missing values (counts and proportions) in the sweCris dataset."}

dlookr::plot_na_pareto(x = sw.Df, col = "blue",typographic = T) + 
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

------------------------------------------------------------------------

> ## 1A. Key: Project number

-   **Exact matches on ID**

The **Project number** variable in CASE correspond to the **Project ID** field in sweCris. However, to facilitate string intersection or matching, one is required to reformat they key in one of the datasets. A cursory view at the sweCris dataset reveal a predominantly consistent ID form/style. For that reason, I chosen to use the sweCris ID format as a baseline for how to 'clean' CASE project numbers.

```{r warning=FALSE,message=FALSE,echo=TRUE,results='hide'}
# Subset CASE by Funding Organisation = Swedish Energy Agency.
sea.ca <- subset(ca.Df, FundingOrganisation == "Energimyndigheten")
# Remove NA and superfluous text.
sea.ca <- sea.ca[!is.na(sea.ca$ProjectNumber),]
sea.ca <- sea.ca[sea.ca$ProjectNumber %in% as.vector(na.omit(sea.ca$ProjectNumber[sapply(sea.ca$ProjectNumber, nchar) == 7])),]
# Add P to number strings.
sea.ca$ProjectNumber <- paste0("P", gsub("","",sea.ca$ProjectNumber))
# Add organisation name to string.
sea.ca$ProjectNumber <- paste(sea.ca$ProjectNumber,"_Energi")
sea.ca$ProjectNumber <- gsub("\\s","", sea.ca$ProjectNumber)
# Repeat: Keep numbers only)
ca.Df["clean.IDA"] <- gsub("[^0-9.-]","",ca.Df$ProjectNumber)
# Keep 10 character elements only.
ca.Df.sub <- ca.Df[ca.Df$clean.IDA %in% as.vector(na.omit(ca.Df$clean.IDA[sapply(ca.Df$clean.IDA, nchar) == 10])),] # 270 observations.
ca.Df.sub$clean.IDA <- gsub("^-","",ca.Df.sub$clean.IDA)
# Remove empty funding organisation.
ca.Df.sub$FundingOrganisation[ca.Df.sub$FundingOrganisation == "Not Applicable N/A"]  <- ""
# Standardize against sweCris names.
ca.Df.sub$FundingOrganisation <- recode(ca.Df.sub$FundingOrganisation,
                                         Energimyndigheten = "Energi",
                                         VINNOVA = "Vinnova",
                                         VetenskapsrÃ¥det = "VR")
# Combine
ca.Df.sub["clean.IDA"]<-paste(ca.Df.sub$clean.IDA,ca.Df.sub$FundingOrganisation,
                              sep = "_")
ca.Df.sub["clean.IDA"] <- gsub("^-","",ca.Df.sub$clean.IDA)
# Combine dataframes.
cleanID.CASE <- dplyr::bind_rows(sea.ca,ca.Df.sub) # 348 observations.
cleanID.CASE[1:78,"clean.IDA"] <- cleanID.CASE[1:78,"ProjectNumber"]
# Remove missing organisations.
cleanID.CASE <- cleanID.CASE[!cleanID.CASE$FundingOrganisation == "",] # 344 observations.
```

```{r echo=TRUE,results='hide'}
# How many in 00000-0_ZZ shape in sweCris? They are all Energy funded 
as.vector(na.omit(str_extract(sw.Df$ProjectId, "(\\d+)-(\\d{1})_[:alpha:]+"))) %>%
  length() # 369 (11.76%)
# How many in 0000-00000_ZZ format?
as.vector(na.omit(str_extract(sw.Df$ProjectId, "(\\d+)-(\\d{5})_[:alpha:]+"))) %>%
  length() # 2680 (85%). In total with the aforementioned = 96.76%
# How many in P00000-0_ZZ format? These are also Energy Funded. 
# This is the same as 00000-0_ZZ.
as.vector(na.omit(str_extract(sw.Df$ProjectId, "([:alnum:]+)-(\\d{1})_[:alpha:]+"))) %>% length() # same as the first one.
```

```{r echo=TRUE, results='hide',message=FALSE}
# Table 1.
Tab.1 <- ca.Df %>%
  group_by(FundingOrganisation) %>%
  count(sort = F)
# Table 2.
Tab.2 <- sw.Df %>%
  group_by(FundingOrganisationNameSv) %>%
  count(sort = F)
# Table 3 (Hypothetical match)
Fund.Org <- c("VR","VINNOVA","Formas","Energimyndigheten",
              "Rymdstyrelsen","Forte","Riksbankens Jubileumsfond")

Tab.3 <- cbind(Tab.2,Tab.1[Tab.1$FundingOrganisation %in% Fund.Org, ])

Tab.3[,3:4] <- Tab.3[c(2,3,4,5,1,7,6),3:4]

colnames(Tab.3)[1] <- "sweCris"
colnames(Tab.3)[2] <- "Sample"
colnames(Tab.3)[3] <- "CASE"
colnames(Tab.3)[4] <- "Sample"
# 698 Projects.
sum(Tab.1[Tab.1$FundingOrganisation %in% Fund.Org, ]$n)
```

```{r echo=TRUE}
knitr::kable(x = Tab.3,
caption = "Table 1. Organizations that fund projects in the CASE dataset. The funding organization is unknown for 560 projects. SweCris has seven funding agencies and CASE has 29. The hypothetical project match is 698",format="markdown")
```

------------------------------------------------------------------------

**Remarks**

1.  The project number field in CASE would benefit from a re-structuring and consistent ID formatting across projects.

2.  Furthermore, project ID's associated with **Swedish Energy Agency** often lack the initial **P** letter. Additionally, many projects lack an ID in entirety, some have more than one ID along with text, and others are made up by text. only.

3.  **ID cleaning was done using a three-step process:**

-   Removal of all non-numeric characters.
-   Retaining all 9 digits + hyphen elements (this is the conventional label shape in sweCris).
-   Add funding organisation to CASE ID.

```{r echo=TRUE,results='hide'}
sweCris.format <- data.frame(Format = c("P00000-0_ZZ","0000-00000_ZZ",
                                        "000/00_ZZ","00/00_ZZ"),
                             Percentage = c("11.76","85.0","1.43","1.88"),
                             N = c(369,2680,45,59),
                             Remarks = c("Swedish Energy Agency affiliated",
                                         "VR, Vinnova, & Formas",
                                         "SNSB affiliated","SNSB affiliated"))
```

```{r echo=TRUE}
knitr::kable(x = sweCris.format,
             caption = "Table 2. There are at least eight different ID styles/formats in sweCri. Together, 0000-00000_ZZ and P00000-0_ZZ make up 96.76% of all ID patterns in sweCris.") %>% 
  kable_styling() %>%
  kableExtra::add_footnote(label = "Not all are shown")
```

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# Subset CASE data (both NA's and duplicates in Project Number are removed)
cleanID.CASE <- cleanID.CASE %>%
  filter(!duplicated(clean.IDA)) %>%
  filter(!duplicated(Name)) # 342 projects.

# Confirm. Looks fine.
which(duplicated(x = cleanID.CASE$Name) == T)
which(duplicated(x = cleanID.CASE$clean.IDA) == T)
# How many ID's match?
generics::intersect(cleanID.CASE$clean.IDA,sw.Df$ProjectId) %>% length() # 124 projects match. This approach might be to stringent. Attempt fuzzy or other methods of matching.

# Initial match. This will add information to those project that match between the datasets.
Match.1 <- cleanID.CASE %>% 
  left_join(sw.Df, by = c("clean.IDA" = "ProjectId")) # adds 27-1 more variables. Check their level of completeness.

# Parse out the projects that matched: this is equivalent to an inner join.
MissCheck.1 <- Match.1[Match.1$clean.IDA %in% generics::intersect(cleanID.CASE$clean.IDA,sw.Df$ProjectId), ]

MissCheck.1 <- MissCheck.1 %>% 
  mutate(across(c("ProjectTitleSv","ProjectTitleEn",
                  "ProjectAbstractSv","ProjectAbstractEn"), na_if, "Unknown"))
MissCheck.1 %>% nrow()

MissCheck.1 %>%
  group_by(FundingOrganisation) %>%
  summarise(n = n()) %>%
  arrange(-n)

# Degree of missingness?
sapply(MissCheck.1[,41:66], function(x) sum(is.na(x)))
```

### Data quality

```{r warning=FALSE,message=FALSE,echo=TRUE,fig.cap="Figure 5. Missing data summary. Pattern of missingness in CASE-specific columns in the reduced data (i.e. remaining projects that satisfies the matching criterion using ID)."}
# Visualize data-quality.
MissCheck.1[,1:40] %>% 
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(axis.text = element_text(size = 5),
        aspect.ratio = 1)
```

```{r warning=FALSE,message=FALSE,echo=TRUE,fig.cap="Figure 6. Missing data summary. Pattern of missingness in sweCris-specific columns in the reduced data (i.e. remaining projects that satisfies the matching criterion using ID)."}
# Visualize data-quality.
MissCheck.1[,41:66] %>% 
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(axis.text = element_text(size = 5),
        aspect.ratio = 1)
```

------------------------------------------------------------------------

```{r echo=TRUE,fig.cap="Figure 7. Pareto chart for missing values (counts and proportions) in the reduced CASE dataset."}
dlookr::plot_na_pareto(x = MissCheck.1, col = "blue",typographic = T) + 
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

**Results (1/4)**

1.  The number of project matches depend on how ID standardization is done.
2.  Using the two predominant ID styles in sweCris (see above) as a reference - yields 124 distinct project matches.
3.  Generally, most CASE ID's are inconsistently written, which makes it very difficult to merge against sweCris.
4.  The issue is further exacerbated by variable ID formats in sweCris. But is generally better than CASE.
5.  Of the **342 CASE projects** with a clean ID, only [**36% (N=124)**]{.underline} could be matched against the sweCris dataset.
6.  Viewed altogether, only **5.03%** of unique CASE projects (N=2434) could be detected in sweCris using project ID as an identifier.
7.  Matching against all sweCris projects (i.e., swe.Total) returns **265** matches.
8.  Other data-set pathology- in CASE include high proportion of missingness and projects with similar project titles (i.e. duplicates).
9.  Overall, despite the low number of project matches, the added information retrieved via sweCris is rather complete (column-wise). This is unsurprising as the data quality in sweCris tends to be better (see Figure 4).

------------------------------------------------------------------------

```{r warning=FALSE,message=FALSE,echo=TRUE,fig.show='hide'}
## Venn diagram showing project overlap based on project ID's.
mP1 <- draw.pairwise.venn(area1= 3137,area2 = 2434,
                          cross.area = 124,
                          category = c("sweCris projects with an ID",
                                       "CASE projects with an ID"),
                          fill = c("grey80","#7b0323"),
                          scaled = T,cex = 1,
                          rotation.degree = 45)
```

```{r echo=TRUE,fig.cap="Figure 8. Venn diagram showing project overlap based on project ID's. Area 1 (Grey) = the total number of unqiue project ID in sweCris. Area 2 (Red) = the total number of unique project number is CASE with a similar ID format."}
ggarrange(mP1) + theme(aspect.ratio = 1)
```

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# Match against all sweCris projects.
allSweCris <- generics::intersect(cleanID.CASE$clean.IDA,swe.Total$projectId) # 265 matches.
allSweDf <- swe.Total[swe.Total$projectId %in% (allSweCris),]
allSweDf <- allSweDf %>% filter(!duplicated(projectId))
# Which are the coordinating organisations?
allSweDf %>% group_by(coordinatingOrganisationNameEn) %>% count(sort = T)
# Compare with CASE.
cleanID.CASE %>% group_by(Role) %>% count(sort = T)
```

> ## 1B. Key: Project number

-   In-exact matches on ID

```{r warning=FALSE, message=FALSE, echo=TRUE}
# Fuzzy matching.
Fuzz.ID <- cleanID.CASE %>%
  stringdist_inner_join(x = sw.Df,by = c(ProjectId = "clean.IDA")) %>%
  filter(!duplicated(clean.IDA)) %>%
  filter(!duplicated(Name)) # 303 matches?

Fuzz.ID["lev"] <- lev <- levenshteinSim(Fuzz.ID$clean.IDA,Fuzz.ID$ProjectId)
```

**Evaluating fuzzy matching**

```{r echo=TRUE}
knitr::kable(slice_head(Fuzz.ID[,c("clean.IDA","ProjectId","lev")],n = 10),
  caption = "Table 3. Fuzzy matching. Lev = similarity (%) between fields",
  digits = 2) %>%
  kable_styling()
```

**Miss-classification rate**

```{r echo=TRUE}
paste(round(100-(which(Fuzz.ID$lev == 1.0000000) %>% 
                   length()/(length(Fuzz.ID$lev)))*100,2),"%")
```

------------------------------------------------------------------------

> ## 2. Key: Project Title.

The main problem with matching against **Project Title** is that CASE does not provide the information in a consistent format/language.

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# How many NA projet titles are there in sweCris?
sum(is.na(sw.Df$ProjectTitleSv)) # 77.
sum(is.na(sw.Df$ProjectTitleEn)) # 420.
# How many NA projet titles are there in CASE?
sum(is.na(ca.Df$Name)) # 3
```

```{r warning=FALSE, message=FALSE, echo=TRUE,results='hide'}
# Add
ca.Df["language"] <- NA
# Language identifier
system.time(
  for(i in 1:length(ca.Df$Name)) {
  ca.Df$language[[i]] <- tolower(cld2::detect_language(text = ca.Df$Name[[i]],
                                                       plain_text = T,
                                                       lang_code = F))
}
)

# Correct
ca.Df$language[ca.Df$language == "norwegian"] <- "swedish"
# Summary.
ca.Df %>%
  group_by(ca.Df$language) %>%
  count(sort = T) %>%
  print(n=45)

# Unknowns, are a mix of Swedish & English titles.
ca.Df$language[is.na(ca.Df$language)] <- "Unknown"
# Other languages?
ca.Df %>% group_by(Name,language) %>%
  dplyr::select(Name,language) %>%
  filter(language == "welsh" | language == "uzbek" | 
         language == "turkish" | language == "portuguese" |
         language == "nyanja" | language == "kurdish" |
         language == "indonesian" | language == "hungarian" |
         language == "galician" | language == "croatian" |
         language == "catalan" | language == "albanian" |
         language == "afrikaans" | language == "spanish" |
         language == "kinyarwanda" | language == "ganda" |
         language == "estonian" | language == "basque" |
         language == "german") %>% 
  print(n = 27)
```

```{r warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
# Subset based on intersection.
# Remove extra spaces and use case-folding to improve intersection.
merge.titles <- c(generics::intersect(x = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT")),
                                      y = gsub("\\s+"," ",iconv(tolower(na.omit(sw.Df$ProjectTitleSv)),to = "ASCII//TRANSLIT"))),
                  generics::intersect(x = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT")),
                                      y = gsub("\\s+"," ",iconv(tolower(na.omit(sw.Df$ProjectTitleEn)),to = "ASCII//TRANSLIT"))))
# Any duplicates? Yes.
duplicated(merge.titles)
# Remove.
merge.titles <- unique(merge.titles) # 136. Although not that good, this is still better than project ID.
# Subset
sub.ca.Df.2 <- ca.Df
sub.ca.Df.2$Name <- gsub("\\s+"," ",iconv(tolower(ca.Df$Name),to = "ASCII//TRANSLIT"))

sub.ca.Df.2 <- sub.ca.Df.2[sub.ca.Df.2$Name %in% merge.titles, ]
sub.ca.Df.2$Name[duplicated(sub.ca.Df.2$Name)]

# Ask the team about this? For now, assume its a true duplicate.
sub.ca.Df.2[sub.ca.Df.2$Name == "innovativ energi- och effekteffektiv vÃ¤rmepump fÃ¶r smÃ¥hus", ]
sub.ca.Df.2[sub.ca.Df.2$Name == "kundinvolvering vid prissÃ¤ttning av digitala erbjudanden", ]
# Clean
sub.ca.Df.2 <-
  sub.ca.Df.2 %>%
  group_by(Name) %>%
  filter(!duplicated(Name))

# sweCris modification to enable inner-join.
modify.sw.Df <- sw.Df
modify.sw.Df$ProjectTitleSv <- gsub("\\s+"," ",iconv(tolower(sw.Df$ProjectTitleSv),to = "ASCII//TRANSLIT"))
modify.sw.Df$ProjectTitleEn <- gsub("\\s+"," ",iconv(tolower(sw.Df$ProjectTitleEn),to = "ASCII//TRANSLIT"))

# Merge in a two step fashion.
parseSwe <- ca.Df %>%
  filter(!is.na(Name)) %>%
  mutate(Name = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT"))) %>%
  group_by(Name) %>% 
  filter(!duplicated(Name)) %>% 
  inner_join(modify.sw.Df, by = c("Name" = "ProjectTitleSv"))
  # distinct(Name)

parseEng <- ca.Df %>%
  filter(!is.na(Name)) %>%
  mutate(Name = gsub("\\s+"," ",iconv(tolower(na.omit(ca.Df$Name)),to = "ASCII//TRANSLIT"))) %>%
  group_by(Name) %>% 
  filter(!duplicated(Name)) %>% 
  inner_join(modify.sw.Df, by = c("Name" = "ProjectTitleEn"))
  # distinct(Name)

# Match by project title enrichment.
Match.2 <- rbind(parseSwe,parseEng)
Match.2 <- Match.2 %>% filter(!duplicated(Name))
```

**Data quality**

```{r echo=TRUE, fig.cap="Figure 9."}
Match.2[,41:68] %>%
  visdat::vis_miss(sort_miss = T,show_perc_col = T) + 
  theme(axis.text = element_text(size = 5),
        aspect.ratio = 1)
```

**Results (2/4)**

1.  136 matches based on Project Title. This is on par with the number of matches captured using Project ID.

```{r echo=TRUE, fig.show='hide'}
## Venn diagram showing projects overlap based on project title.
mP2 <- draw.pairwise.venn(area1= 3137,area2 = 2434,
                          cross.area = 136,
                          category   = c("SweCris-titled projects",
                                         "CASE-titled projects"),
                          fill = c("grey80","darkcyan"),
                          scaled = T,cex = 1,rotation.degree = 45)
```

```{r echo=TRUE,fig.cap="Figure 10. Venn diagram showing project overlap based on project title. Area 1 (Grey) = represent unique project ID in sweCris, instead of project title. This is because the length of unique titles differ between the Swedish and English titles. Area 2 (Red) = represent unique project names (i.e. title) in CASE."}
ggarrange(mP2) + theme(aspect.ratio = 1)

```

------------------------------------------------------------------------

**Combined results**

```{r fig.cap="Figure 11. Comparison of results",fig.align='center'}
ggarrange(mP1,mP2) + theme(aspect.ratio = 1/2)
```

**Does ID vs Title identifiers return the same matching projects?**

No. Only, 74 projects are the same. In other words, the project match depend to some extent on the identifier being used. Jointly, however, ID and Project Title yield **189 project matches** against sweCris.

```{r echo=TRUE,results='hide'}
generics::intersect(gsub("\\s+"," ",
                         iconv(tolower(na.omit(MissCheck.1$Name)),
                               to = "ASCII//TRANSLIT")),Match.2$Name)

generics::setdiff(gsub("\\s+"," ",
                       iconv(tolower(na.omit(MissCheck.1$Name)),
                             to = "ASCII//TRANSLIT")),Match.2$Name)
# Combine.
Total.M1 <- merge(MissCheck.1,Match.2,all = T)
Total.M1$Name <- iconv(tolower(Total.M1$Name),to = "ASCII//TRANSLIT")
# Subset.
Total.M1 <- Total.M1 %>%
  filter(!duplicated(Name))
```

------------------------------------------------------------------------

> ## 3. Key: Primary Researcher

1.  The **InvolvedPeople** column have a complex string structure with relevant information that ought to be parsed out to facilitate maximum matching with the CASE database. The main problem here is that the name of the project leaders, including participating researchers are bind into poorly structured text strings. To circumvent, I have attempted to parse out **name** and **role** based on their general position in each string.

2.  The **primary researcher** information is missing from 696 projects in SweCris. 14 of these do however include partial information, but not the name of the PI.

3.  The name of 2441 Principal Investigators (71.81%) could successfully be collected via sweCris.

4.  **372 exact name matches between CASE and sweCRIS.**

```{r echo=TRUE}
sw.Df["PrimaryResearcher"] <- ""
sw.Df["Leading.Role"] <- ""

# Generalize.
for(i in 1:length(sw.Df$InvolvedPeople)) {
  # Index.
  iX <- strsplit(sw.Df$InvolvedPeople[[i]],"Â¤")[[1]][-c(1:3)]
  # Attain name via PI position
  sw.Df$PrimaryResearcher[[i]] <- iX[grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[i]],"Â¤")[[1]][-c(1:3)])[1]-2]
  # Clean names, with no extra spaces.
  sw.Df$PrimaryResearcher[[i]] <- gsub("\\s+"," ",sw.Df$PrimaryResearcher[[i]])
  # Remove accents.
  # sw.Df$PrimaryResearcher[[i]] <- iconv(sw.Df$PrimaryResearcher[[i]],to = "ASCII//TRANSLIT")
  # Role.
  sw.Df$Leading.Role[[i]] <- iX[grep("Principal Investigator",strsplit(sw.Df$InvolvedPeople[[i]],"Â¤")[[1]][-c(1:3)])[1]]
}
```

```{r echo=TRUE,results='hide'}
# Summarize.
sw.Df %>% group_by(Leading.Role) %>% count(sort = T)
sw.Df %>% group_by(PrimaryResearcher) %>% filter(PrimaryResearcher != "Unknown") %>% count(sort = T)
ca.Df %>% group_by(PrimaryResearcher) %>% count(sort = T)
```

```{r echo=TRUE,results='hide'}
# Re-code.
sw.Df[is.na(sw.Df)] <- "Unknown"
sw.Df.Unknown <- subset(sw.Df,(Leading.Role %in% "Unknown"))
# Rows (n=14) were Involved People have limited information, but not Principal Investigator.
string.InNA <- c(215,270,278,324,402,405,444,447,505,509,530,572,605,606)
# Subset to retain all NA.
sw.df.Partial <- sw.Df.Unknown[string.InNA, ]
```

```{r echo=TRUE,results='hide'}
# Remove accent from names in CASE:
# ca.Df$PrimaryResearcher <- iconv(ca.Df$PrimaryResearcher,to = "ASCII//TRANSLIT")

# How many matches?
generics::intersect(na.omit(ca.Df$PrimaryResearcher),
                    na.omit(sw.Df$PrimaryResearcher)) %>% unique()
generics::intersect(na.omit(ca.Df$PrimaryResearcher),
                    na.omit(sw.Df$PrimaryResearcher)) %>% unique() %>% length()
generics::intersect(na.omit(ca.Df$PrimaryResearcher),
                    na.omit(sw.Df$PrimaryResearcher)) %>% length()
```

```{r echo=TRUE}
# Match.
Match.3 <- ca.Df %>% 
  left_join(sw.Df, by = "PrimaryResearcher",na_matches = "never") %>%
  filter(!is.na(PrimaryResearcher)) %>%
  filter(!is.na(Leading.Role)) %>%
  filter(!duplicated(Name)) %>%
  filter(!duplicated(ProjectTitleEn))
```

```{r echo=TRUE,fig.cap="Figure 12. Pareto chart for missing values (counts and proportions) in the reduced CASE dataset."}
dlookr::plot_na_pareto(x = Match.3, col = "blue",typographic = T) + 
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```

**Results (3/4)**

1.  370 exact name matches. Better than ID and Project title combined. But this is probably an underestimation anyway. The complete name may not include 'middle names' in CASE.

```{r echo=TRUE,fig.show='hide'}
## Venn diagram showing projects overlap based on project title.
mP3 <- draw.pairwise.venn(area1= 3137,area2 = 1623,
                          cross.area = 370,
                          category = c("SweCris: Primary Researcher",
                                       "CASE: PrimaryResearcher"),
                          fill = c("grey80","blue"),
                          cat.col = "black",cat.cex = 1,
                          scaled = T,cex = 1,
                          rotation.degree = 45)
```

```{r echo=TRUE,fig.cap="Figure 13. Venn diagram showing project overlap based on Primary Researcher Area 1 (Grey) =  Area 2 (Red) = "}
ggarrange(mP3) + theme(aspect.ratio = 1)
```

------------------------------------------------------------------------

> ## Summary

-   **Total number of matches**

513 unique projects in total can be matched based on ID, Title, and Primary Researcher. That means of the 698 potential project fits, we are able to capture 73%. But that also means that 27% are missing.

```{r echo=TRUE}
# Combine ID, Title, and Primary Research
Total.M2 <- merge(Total.M1,Match.3,all = T)
Total.M2$Name <- tolower(iconv(Total.M2$Name,to = "ASCII//TRANSLIT"))
Total.M2 <- Total.M2 %>% filter(!duplicated(Name)) # 513 unique projects in total.
```

```{r echo=TRUE,fig.cap="Figure 14. Venn diagram showing project overlap based on Id, Title, and Primary Researcher."}
ggarrange(mP1,mP2,mP3,nrow = 1,heights = c(2,2),widths = c(4,4)) + 
  theme(aspect.ratio = 1/2)
```

------------------------------------------------------------------------

> ## 4. External Key: ORCID ID

```{r echo=TRUE,results='hide',message=FALSE,warning=FALSE}
# ugkthId & Orcid
ug <- readr::read_csv(rawToChar(kthcorpus::minio_get("ug_kthid_orcid.csv",
                                                     bucket = "kthcorpus")))
# unique ugkthId
lookup <- readr::read_csv(rawToChar(kthcorpus::minio_get("ug_kthid_unit.csv",
                                                         bucket = "kthcorpus")))
```

```{r echo=TRUE, results='hide'}
# Merge by username and remove incomplete cases (subset by ugOrcid)
exDf.ca <- ca.Df %>%
  left_join(lookup, by = c("username" = "ugUsername")) %>%
  filter(!is.na(ugOrcid)) %>%
  filter(!duplicated(ProjectNumber)) %>%
  filter(!duplicated(Name)) # 833 unique projects

NROW(exDf.ca) # 832 projects.

# sapply(exDf.ca[c("ProjectNumber","Name")],function(x) duplicated(x))
```

**Call sweCris api to get project results**

```{r}
# Can we match by ORCiD?
# Function to look-up projects from SweCRIS via ORCiD.
 swecris_projects_from_orcid <- function(orcid) {
  route <-
  sprintf(
    paste0("https://swecris-api.vr.se",
           "/v%s/projects/persons/orcId/%s")
    , 1, URLencode(orcid))
  
  res <- swecris:::swecris_get(route)
  
  fields <- c(
    "projectId",
    "projectTitleSv",
    "projectTitleEn",
    "projectAbstractSv",
    "projectAbstractEn",
    "projectStartDate",
    "projectEndDate",
    "coordinatingOrganisationId",
    "coordinatingOrganisationNameSv",
    "coordinatingOrganisationNameEn",
    "coordinatingOrganisationTypeOfOrganisationSv",
    "coordinatingOrganisationTypeOfOrganisationEn",
    "fundingOrganisationId",
    "fundingOrganisationNameSv",
    "fundingOrganisationNameEn",
    "fundingOrganisationTypeOfOrganisationSv",
    "fundingOrganisationTypeOfOrganisationEn",
    "fundingsSek",
    "fundingYear",
    "fundingStartDate",
    "fundingEndDate",
    "typeOfAwardId",
    "typeOfAwardDescrSv",
    "typeOfAwardDescrEn")

  projects <- res %>%
    purrr::map_df(.f = function(x) x[fields] %>% as_tibble())
  
  peopleList <-
    res %>%
    purrr::map_df(.f = purrr::pluck(c("peopleList")))
  
  scbs <-
    res %>%
    purrr::map_df(.f = purrr::pluck(c("scbs")))
  
  list(projects = projects)
}
```

```{r echo=TRUE,results='hide'}
orSwe.Df <- read.xlsx(file = "ocridSweDf.xlsx",sheetIndex = 1)
orSwe.Df <- orSwe.Df[,-1]
```

```{r echo=TRUE,fig.cap="Figure 15."}
dlookr::plot_na_pareto(x = orSwe.Df, col = "blue",typographic = T) + 
  theme(axis.text.x = element_text(size = 7),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9), 
        axis.title.y.right = element_text(size = 9))
```
